'TESTT add registers stack_start (on launch) and stack_max (on call or return) to track stack size for allocation need

'******************************************
'*  Spin2 Interpreter - v46 - 2024.11.20  *
'******************************************
'
CON	bc_setup_reg_1D8_1F8	= $B0
	bc_setup_var_0_15	= $C0
	bc_setup_local_0_15	= $D0
	bc_read_local_0_15	= $E0
	bc_write_local_0_15	= $F0
'
'
' Set clock mode, clear first 16 hub longs and VAR space, then start interpreter
'
DAT		org

		mov	y,clkmode_hub		'set clock mode
		mov	z,clkfreq_hub
		call	#clkset_init

		setq	#16-1			'clear $00..$3F in hub (this code space)
		wrlong	#0,#0

		setq	var_longs		'clear VAR space
		wrlong	#0,vbase_init

		setq	#2-1			'init stack with pbase/vbase
		wrlong	pbase_init,dbase_init

		setq	dbase_init		'restart cog 0 with interpreter
		coginit	#hubexec,##launch_spin


pbase_init	long	@test_pbase + 8				'$30 - compiler supplies initial pbase value, +8 without compiler
vbase_init	long	@test_vbase + 0 << 20			'$34 - compiler supplies initial vbase value, first pub in [31:20]
dbase_init	long	@test_dbase				'$38 - compiler supplies initial dbase value
var_longs	long	(@test_dbase - @test_vbase) >> 2	'$3C - compiler supplies VAR longs to clear
clkmode_hub	long	%1_000000_0000001111_1111_10_11		'$40 - compiler supplies initial clkmode value
clkfreq_hub	long	320_000_000				'$44 - compiler supplies initial clkfreq value
'
'
' Unaligned data
'
		orgh

stopcog		byte	bc_cogid		& $FF	'cogstop(cogid)
		byte	bc_cogstop		& $FF

pri_sendb	byte	0				'no locals		PRI sendb(count,addr)
		byte	bc_read_local_0_15+0		'read count		  repeat count
.loop		byte	bc_setup_local_0_15+1		'setup addr		    send(byte[addr++])
		byte	bc_var_postinc_push	& $FF	'addr++
		byte	bc_setup_byte_pa	& $FF	'setup byte
		byte	bc_read			& $FF	'read
		byte	bc_call_send		& $FF	'call send
		byte	bc_djnz			& $FF	'djnz
		byte	(.loop-$) & $7F			'loop address
		byte	bc_return_results	& $FF	'return
'
'
' Hub bytecode vectors (up to $FE possible)
'
		alignw			'word-align for vectors

bc_hubset	word	@hubset_	'HUBSET(val)				$54	miscellaneous routines
bc_clkset	word	@clkset_	'CLKSET(clkmode,clkfreq)		$56	(use ctrl-l to determine address)
bc_read_clkfreq	word	@read_clkfreq	'CLKFREQ			(push)	$58
bc_cogspin	word	@cogspin_	'COGSPIN(cog,method(params),stackadr)	$5A
bc_cogchk	word	@cogchk_	'COGCHK(cog)			(push)	$5C
bc_inline	word	@inline		'inline pasm code			$5E
bc_regexec	word	@regexec_	'REGEXEC(hubadr)			$60
bc_regload	word	@regload_	'REGLOAD(hubadr)			$62
bc_call		word	@call_		'CALL(anyadr)				$64
bc_getregs	word	@getregs_	'GETREGS(hubadr,cogadr,longs)		$66
bc_setregs	word	@getregs_	'SETREGS(hubadr,cogadr,longs)		$68
bc_bytefill	word	@bytefill_	'BYTEFILL(dst,val,cnt)			$6A	(bit2..1=01)	(<bc_wordfill)
bc_bytemove	word	@bytefill_	'BYTEMOVE(dst,src,cnt)			$6C	(bit2..1=10)
bc_byteswap	word	@bytefill_	'BYTESWAP(adra,adrb,cnt)		$6E	(bit2..1=11)
bc_bytecomp	word	@bytefill_	'BYTECOMP(adra,adrb,cnt)	(push)	$70	(bit2..1=00)
bc_wordfill	word	@wordfill_	'WORDFILL(dst,val,cnt)			$72	(bit2..1=01)	(<bc_longfill)
bc_wordmove	word	@wordfill_	'WORDMOVE(dst,src,cnt)			$74	(bit2..1=10)
bc_wordswap	word	@wordfill_	'WORDSWAP(adra,adrb,cnt)		$76	(bit2..1=11)
bc_wordcomp	word	@wordfill_	'WORDCOMP(adra,adrb,cnt)	(push)	$78	(bit2..1=00)
bc_longfill	word	@longfill_	'LONGFILL(dst,val,cnt)			$7A	(bit2..1=01)
bc_longmove	word	@longfill_	'LONGMOVE(dst,src,cnt)			$7C	(bit2..1=10)
bc_longswap	word	@longfill_	'LONGSWAP(adra,adrb,cnt)		$7E	(bit2..1=11)
bc_longcomp	word	@longfill_	'LONGCOMP(adra,adrb,cnt)	(push)	$80	(bit2..1=00)
bc_strsize	word	@strsize_	'STRSIZE(adr)			(push)	$82
bc_strcomp	word	@strcomp_	'STRCOMP(adra,adrb)		(push)	$84
bc_strcopy	word	@strcopy_	'STRCOPY(dst,src,max)			$86
bc_getcrc	word	@getcrc_	'GETCRC(ptr,poly,cnt)		(push)	$88
bc_waitus	word	@waitus_	'WAITUS(us)				$8A
bc_waitms	word	@waitus_	'WAITMS(ms)				$8C
bc_getms	word	@getms_		'GETMS()			(push)	$8E
bc_getsec	word	@getms_		'GETSEC()			(push)	$90
bc_muldiv64	word	@muldiv64_	'MULDIV64(m1,m2,d)		(push)	$92
bc_qsin		word	@qsin_		'QSIN(rho,theta,twopi)		(push)	$94
bc_qcos		word	@qsin_		'QCOS(rho,theta,twopi)		(push)	$96
bc_rotxy	word	@rotxy_		'ROTXY(x,y,t)			(push2)	$98	(<bc_polxy)
bc_polxy	word	@polxy_		'POLXY(r,t)			(push2)	$9A	(=bc_polxy)
bc_xypol	word	@polxy_		'XYPOL(x,y)			(push2)	$9C	(>bc_polxy)

bc_float	word	@float_		'FLOAT(integer)			(push)	$9E	floating-point routines
bc_trunc	word	@round_		'TRUNC(float)			(push)	$A0	(bit1=0)
bc_round	word	@round_		'ROUND(float)			(push)	$A2	(bit1=1)
bc_fneg		word	@fneg_		'-. float			(push)	$A4
bc_fabs		word	@fabs_		'FABS(float)			(push)	$A6
bc_fsqrt	word	@fsqrt_		'FSQRT(float)			(push)	$A8
bc_fadd		word	@fadd_		'float +. float			(push)	$AA
bc_fsub		word	@fsub_		'float -. float			(push)	$AC
bc_fmul		word	@fmul_		'float *. float			(push)	$AE
bc_fdiv		word	@fdiv_		'float /. float			(push)	$B0
bc_flt		word	@frel_		'float <.  float		(push)	$B2	(bit3..1=001)
bc_fgt		word	@frel_		'float >.  float		(push)	$B4	(bit3..1=010)
bc_fne		word	@frel_		'float <>. float		(push)	$B6	(bit3..1=011)
bc_fe		word	@frel_		'float ==. float		(push)	$B8	(bit3..1=100)
bc_flte		word	@frel_		'float <=. float		(push)	$BA	(bit3..1=101)
bc_fgte		word	@frel_		'float >=. float		(push)	$BC	(bit3..1=110)
bc_nan		word	@nan_		'NAN(float)			(push)	$BE

bc_pinread	word	@pinread_	'PINREAD(pins)			(push)	$C0	miscellaneous routines
bc_pinwrite	word	@pinwrite_	'PINWRITE(pins,val)			$C2
bc_pinstart	word	@pinstart_	'PINSTART(pins,mode,xval,yval)		$C4
bc_pinclear	word	@pinclear_	'PINCLEAR(pins)				$C6

		alignl			'long-align for rest of interpreter
'
'
'*********************************
'*  Interpreter - cog registers  *
'*********************************
'
		org	$120		'start of reg code (user area below)
reg_code
'
'
' Miscellaneous				(28 longs)
'
debug_		pusha	x		'a 			a: DEBUG()
popx		rfvar	x		'a b			b: pop #rfvar
		sub	ptra,x		'a b			c: PINLOW(pins)
pinl_		drvl	x		'| | c			d: PINHIGH(pins)
pinh_		drvh	x		'| | | d		e: PINTOGGLE(pins)
pint_		drvnot	x		'| | | | e		f: PINFLOAT(pins)
pinf_		fltl	x		'| | | | | f		g: AKPIN(pins)
akpin_		akpin	x		'| | | | | | g
pop1	_ret_	popa	x		'| b c d e f g
		popa	x		'a			(continued in string_ + branch + hub_code)
'
'
' STRING()
'
string_		rfbyte	w		'a b			b: STRING() - push string address and jump over string
	_ret_	brk	w		'a |
		pusha	x		'  b
		add	pb,#1		'  b
		mov	x,pb		'  b			(continued in branch + hub_code)
'
'
' Branches - jmp, jz, jnz, tjz, djnz
'
branch		rfvars	w		'  | c d e f g		c: jmp	- branch
		test	x	wz	'  | | d e f |		d: jz	- test, pop, branch if z
		popa	x		'  | | d e | |		e: jnz	- test, pop, branch if nz
	if_nz	ret			'  | | d | f |		f: tjz	- test, if z then pop and branch
		sub	x,#1	wz	'  | | | | | g		g: djnz	- dec, if z then pop, else branch
	if_z	popa	x		'  | | | | f g
	if_z	ret			'  | | | e | g
		add	pb,w		'  b c d e f g		(continued in hub_code)
'
'
' Call hub bytecode routine
'
hub_code	rfbyte	pa		'  | | | | | |		get function index byte
		getptr	pb		'  | | | | | |		get updated bytecode pointer
		rdword	v,pa	wcz	'  | | | | | |		lookup function address
		call	v		'  | | | | | |		call function in hub, c/z/v[31]=0
resume	_ret_	rdfast	#0,pb		'  b c d e f g		resume bytecode stream
'
'
' Variable assignments / math operators	(21 longs)
'
una_iso		mov	w,x		'	m				a: !!
una_psh		pusha	x		'push	| n				b: !			
		alti	rd		'rd	m n				c: - (neg)
op_notb		test	x	wz	'rd,!!	m n a				d: ABS
op_quna		rep	#99,#1		'	x x |               i j k	e: ENCOD	use REP to protect cordic operation until ret/_ret_
		qsqrt	x,#0		'SQRT	x x |               i | |	f: DECOD
		qlog	x		'LOG	x x |               | j |	g: BMASK
		qexp	x		'EXP	x x |               | | k	h: ONES
		muxz	x,_FFFFFFFF	'!!	x x a               | | |	i: SQRT
op_not		not	x		'!	x x | b             | | |	j: QLOG
op_neg		neg	x		'-	x x | | c           | | |	k: QEXP
op_abs		abs	x		'ABS	x x | | | d         | | |
op_encod	encod	x		'ENCOD	x x | | | | e       | | |
op_decod	decod	x		'DECOD	x x | | | | | f     | | |
op_bmask	bmask	x		'BMASK	x x | | | | | | g   | | |
op_ones		ones	x		'ONES	x x | | | | | | | h | | |
		getqx	x		'	x x | | | | | | | | i j k
		alti	wr		'wr	m n | | | | | | | | | | |
		ret			'wr,op	m n a b c d e f g h i j k	m: ?= var	(isolated)
	_ret_	mov	x,w		'iso	m |				n: ?= var	(push)
	_ret_	zerox	x,sz		'push	  n				x: use a..k
'
'
' Variable assignments / math operators	(16 longs)
'
sha_mod		mov	w,x		'	x x a b c d e       i j		a: >>
rev_mod		not	w,x		'	x x | | | | | f g h | |		b: <<
		alti	rd		'rd	m n | | | | | | | | | |		c: SAR
		popa	x		'rd,op	m n a b c d e f g h i j		d: ROR
		rev	x		'REV	x x | | | | | f | | | |		e: ROL
		shl	x,w		'<<	x x | b | | | | g h | |		f: REV
		shr	x,w		'>>	x x a | | | | f g | | |		g: ZEROX
		sar	x,w		'SAR	x x | | c | | | | h | |		h: SIGNX
		ror	x,w		'ROR	x x | | | d | | | | | |		i: +
		rol	x,w		'ROL	x x | | | | e | | | | |		j: -
		add	x,w		'+	x x | | | | | | | | i |
		sub	x,w		'-	x x | | | | | | | | | j
		alti	wr		'wr	m n | | | | | | | | | |
		ret			'wr,op	m n a b c d e f g h i j		m: var ?= exp	(isolated)
	_ret_	popa	x		'iso	m |				n: var ?= exp	(push)
	_ret_	zerox	x,sz		'push	  n				x: use a..j
'
'
' Variable assignments / math operators	(27 longs)
'
mul_mod		abs	w,x	wc	'C=ys	x x   b   d     g		a: *
muu_mod		mov	w,x		'	x x a | c | e f | h		b: /
		alti	rd		'rd	m n | | | | | | | |		c: +/
		popa	x		'rd,op	m n a b c d e f g h		d: //
		testb	x,#31	wz	'Z=xs	x x | b | d | | g |		e: +//
		abs	x		'	x x | b | d | | g |		f: SCA
		rep	#99,#1		'	x x a b c d e f g h		g: SCAS		use REP to protect cordic operation until call/ret/_ret_
		qmul	x,w		'*,SCAx	x x a | | | | f g |		h: FRAC
		qdiv	x,w		'/,//	x x | b c d e | | |
		qfrac	x,w		'FRAC	x x | | | | | | | h
		getqx	x		'	x x a b c | | | | h
    if_c_ne_z	neg	x		'*,/	x x | b | | | | | |
		getqy	x		'	x x | | | d e f g |
    if_z	neg	x		'//	x x | | | d | | | |
		getqx	w		'SCAS	x x | | | | | | g |
		call	#\.scas		'SCAS	x x | | | | | | g |
		alti	wr		'wr	m n | | | | | | | |
		ret			'wr,op	m n a b c d e f g h		m: var ?= exp	(isolated)
	_ret_	popa	x		'iso	m |				n: var ?= exp	(push)
	_ret_	zerox	x,sz		'push	  n				x: use a..h

.scas if_c_eq_z	jmp	#.scas2		'adjust 64-bit product for SCAS
		neg	w	wz	'conditionally negate {x,w}
    if_nz	not	x
    if_z	neg	x
.scas2		shl	x,#2		'x = {x,w}[61:30]
		shr	w,#32-2
	_ret_	or	x,w
'
'
' Variable assignments / math operators	(19 longs)
'
add_mod		and	x,#$1F		'addpb	                    i j		a: &&
		shl	x,#5		'addb	                    i |		b: ^^
		shl	x,#6		'addp	                    | j		c: ||
log_mod		mov	w,x	wz	'	x x a b c d e f g h i j		d: &
		muxnz	w,_FFFFFFFF	'bool	x x a b c | | | | | | |		e: ^
		alti	rd		'rd	m n | | | | | | | | | |		f: |
		popa	x	wz	'rd,op	m n a b c d e f g h i j		g: #>
		muxnz	x,_FFFFFFFF	'bool	x x a b c | | | | | | |		h: <#
		and	x,w		'&&,&	x x a | | d | | | | | |		i: ADDBITS
		xor	x,w		'^^,^	x x | b | | e | | | | |		j: ADDPINS
		and	x,#$1F		'addb	x x | | | | | | | | i |
		and	x,#$3F		'addp	x x | | | | | | | | | j
		or	x,w		'||,|	x x | | c | | f | | i j
		fges	x,w		'#>	x x | | | | | | g | | |
		fles	x,w		'<#	x x | | | | | | | h | |
		alti	wr		'wr	m n | | | | | | | | | |
		ret			'wr,op	m n a b c d e f g h i j		m: var ?= exp	(isolated)
	_ret_	popa	x		'iso	m |				n: var ?= exp	(push)
	_ret_	zerox	x,sz		'push	  n				x: use a..h
'
'
' Variable pre/post modifiers		(29 longs, must be in regs)
'
mod_iso		mov	w,x		'iso	a b         g   i   k l		a: ++var, var++	(isolated)
mod_psh		pusha	x		'push	| | c d e f | h | j | | m	b: --var, var--	(isolated)
		alti	rd		'rd	a b c d e f g h i j k l m	c: ++var	(push)
rd_field	call	#\rdf		'rd	a b c d e f g h i j k l m	d: --var	(push)		(pipeline spacer)
		xoro32	x		'??	| | | | | | | | | | | l m	e: var++	(push)	
		mov	v,x		'post	| | | | e f | h | j k l m	f: var--	(push)
		add	x,incdec	'++	a | c | e | | | | | | | |	g: var!!	(isolated)
repvarin	sub	x,incdec	'--	| b | d | f | | | | | | |  n	h: var!!	(push)
		mov	incdec,#1	'++/--	a b c d e f | | | | | | |  |	i: var!		(isolated)
		zerox	x,sz		'ptr	| | c d | | | | | | | | |  |	j: var!		(push)
		pusha	x		'0..n-1	| | | | | | | | | | | | |  n	k: var\new	(swap)
		muxz	x,_FFFFFFFF	'!!	| | | | | | g h | | | | |  n	l: ??var	(isolated)
		not	x		'!	| | | | | | | | i j | | |  |	m: ??var	(push)
		mov	x,w		'swap	| | | | | | | | | | k | |  |
		alti	wr		'wr	a b c d e f g h i j k l m  |
wr_field	call	#\wrf		'wr	a b c d e f g h i j k l m  |					(pipeline spacer)
	_ret_	mov	x,w		'iso	a b | | | | g | i | | l |  |
	_ret_	mov	x,v		'iso	    | | e f   h   j k   m  |
		ret			'main	    c d                    |	n: REPEAT-var init, 0..n-1	(followed by repvari1)
'
'
' REPEAT-var init			(must be in regs)
'
'  x		initial
'  ptra[-1]	delta
'  ptra[-2]	terminal
'  ptra[-3]	address
'
repvari1	pusha	#1		'set step to 1 (insert between terminal and initial)

repvari		alti	wr		'write variable
_FFFFFFFF	long	$FFFFFFFF	'(pipeline spacer)

		setq	#2-1		'pop terminal/delta into y/z
		rdlong	y,--ptra

		add	ptra,#2*4	'repoint to top of stack

		cmps	y,x	wc	'sign-correct delta
		abs	z
	if_c	neg	z
	_ret_	wrlong	z,ptra[-1]
'
'
' REPEAT-var loop			(11 longs, must be in regs)
'
'  x		current (was initial)
'  ptra[-1]	delta
'  ptra[-2]	terminal
'  ptra[-3]	address
'
repvarl		setq	#3-1		'pop address/terminal/delta into a/b/c
		rdlong	a,--ptra

		add	x,c		'add delta into current

		alti	wr		'write variable
dcall		long	0		'(pipeline spacer)

		testb	c,#31	wz	'check for out-of-bounds
	if_nz	cmps	b,x	wc
	if_z	cmps	x,b	wc

	if_nc	add	ptra,#3*4	'if not out-of-bounds, unpop data and loop
	if_nc	jmp	#absjmp

	_ret_	popa	x		'out-of-bounds, pop stack, continue
'
'
' Read bitfield				(3 longs, must be in regs)
'
rdf		long	@lut_code	'read variable into x (rewritten)

		ror	x,fb		'lsb-justify bitfield

	_ret_	zerox	x,sz	wz	'trim it, affect z
'
'
' Write bitfield			(12 longs, must be in regs)
'
wrf		mov	fd,x		'get bitfield data
		rol	fd,fb

		bmask	fm,sz		'make bitfield mask
		rol	fm,fb

		mov	fx,x		'preserve x
		rep	@stall,#1	'use REP to protect variable from interrupts
wrf_rd		push	#$1FF		'read variable into x (rewritten)	(initially: push $1FF, to begin xbyte on _ret_)
		setq	fm		'set bitfield mask			(initially: no consequence)
		muxq	x,fd		'mux bitfield data into x		(initially: no consequence)
wrf_wr	_ret_	setq	#$1A1		'write x back to variable (rewritten)	(initially: begin xbyte, compress Ax..Fx, write flags)
stall	_ret_	mov	x,fx		'restore x
'
'
' Read/write instructions		(8 longs, must be in regs)
'
rd_byte		rdbyte	x,ad	wz	'all reads affect z
rd_word		rdword	x,ad	wz
rd_long		rdlong	x,ad	wz
rd_reg		mov	x,0	wz

wr_byte		wrbyte	x,ad
wr_word		wrword	x,ad
wr_long		wrlong	x,ad
wr_reg		mov	0,x
'
'
' ++/-- value				(1 long, must be in regs)
'
incdec		long	1		'default ++/-- value is 1, gets modified for pointer operations
'
'
' End of cog register code
'
reg_end
'
'
' Interpreter registers
'
v		res	1		'v/pbase/vbase/dbase/mrecv/msend/w/x/y/z must remain in order
pbase		res	1
vbase		res	1
dbase		res	1
mrecv		res	1
msend		res	1
w		res	1
x		res	0
ma		res	1		'(x alias for float operations)
y		res	1
z		res	1
'
'
' PASM registers - 8 longs
'
pr0_		res	1		'pasm-use registers at $1D8
pr1_		res	1
pr2_		res	1
pr3_		res	1
pr4_		res	1
pr5_		res	1
pr6_		res	1
pr7_		res	1
'
'
' Buff registers - 16 longs
'
buff					'buff registers at $1E0

rd		res	1		'variable registers
wr		res	1
sz		res	1
ad		res	1

fd		res	1		'bitfield registers
fb		res	1
fm		res	1
fx		res	1

a		res	0		'a/b/c/d/e/f/g/h must remain in order
na		res	1		'(a alias for float operations)
b		res	0
sa		res	1		'(b alias for float operations)
c		res	0
xa		res	1		'(c alias for float operations)
d		res	0
mb		res	1		'(d alias for float operations)
e		res	0
nb		res	1		'(e alias for float operations)
f		res	0
sb		res	1		'(f alias for float operations)
g		res	0
xb		res	1		'(g alias for float operations)
h		res	1

		fit	$1F0		'buff occupies $1E0..$1EF, adjust user area size to fit
'
'
'***************************
'*  Interpreter - cog LUT  *
'***************************
'
		org	$210		'leave $20x open for 16 streamer imm->LUT->DAC/pin values
lut_code
'
'
' Free space				(2 longs)
'
		long	0[2]
'
'
' Drop anchor				(8 longs)
'
'	     dcall --> next_dbase[-1]	(push)
'	next_dbase --> dcall
'
'
'  ptr[+0] <-- v := x			(current top of stack)
'  ptr[+1] <-- pbase | flags		(trap_flag into bit 1, push_flag into bit 0)
'  ptr[+2] <-- vbase
'  ptr[+3] <-- dbase
'  ptr[+4] <-- mrecv
'  ptr[+5] <-- msend
'  ptr += 6				(point to new top of stack)
'  x (tos) <-- dcall			(top of stack = dcall)
'  dcall = ptr + 1*4			(set new dcall)
'
drop		or	pbase,pa	'get trap_flag into bit 1, get push_flag into bit 0

drophot		mov	v,x		'get top of stack into v

		setq	#6-1		'push v/pbase/vbase/dbase/mrecv/msend
		wrlong	v,ptra++	'ptra points to dcall in stack

		mov	x,dcall		'get dcall (prior dbase) into top of stack

		mov	dcall,ptra	'update dcall (next dbase)
		add	dcall,#1*4

	_ret_	andn	pbase,#%11	'clear bits 1..0 in pbase
'
'
' Call method / Make method pointer	(14 longs)
'
'	    dcall --> dbase		(pop)
'	dbase[-1] --> dcall
'	  retaddr --> dbase[-1]
'
'
callobj		rfvar	w		'a b         g   i j	get obj into w
callsub		rfvar	v		'a b c       |   i j k	get sub into v
		getptr	pb		'a b c       g   i j k	get updated bytecode ptr
		jmp	#callh		'a b |       |   i j k	continue in hub
		jmp	#callsubh	'    c       |		continue in hub ('call sub' is optimized)
callptr		jmp	#callptrh	'      d     |		continue in hub
callrecv	jmp	#callrecvh	'        e   |		continue in hub
callsend	jmp	#callsendh	'          f |		continue in hub
		jmp	#callsendbh	'            g		continue in hub

callgo		rdfast	#0,x		'a b c d e f g h	return from hub, start new bytecode read
		rfvar	x		'a b c d e f g h	get number of local longs
	_ret_	djnf	x,#.clear	'a b c d e f g h	if zero, continue
.clear		setq	x		'a b c d e f g h	else, clear locals and point stack past them
	_ret_	wrlong	#0,ptra++	'a b c d e f g h
'
'
' Setup reg variable			(11 longs)
'
reg_im		signx	pa,#3		'a		a: setup reg[$1D8..$1DF]/[$1F8..$1FF]
		or	pa,#$1D8	'a		b: setup reg[rfvars]
					'		c: setup reg[rfvars][index]
reg_ap		rfvars	pa		'| b c
		add	pa,x		'| | c
		popa	x		'| | c

		mov	rd,rd_reg	'a b c
		mov	wr,wr_reg	'a b c

		sets	rd,pa		'a b c
		setd	wr,pa		'a b c

		mov	sz,#31		'a b c

	_ret_	setq2	#$0E1		'a b c		(next bytecode is a variable operator)
'
'
' Setup hub variable			(22 longs)
'
hub_im		getnib	ad,pa,#0	'a b							a: setup long[vbase][0..15]
hub_ap		rfvar	ad		'| | c d e f g h i j k l m n o p q r s t		b: setup long[dbase][0..15]
hub_pp		popa	ad		'| | | | | | | | | | | | | | | | | | | | u v w		c: setup byte[pbase + rfvar]
					'							d: setup byte[vbase + rfvar]
		shl	x,#2		'| | | | | | | | | | | | | | | | | r s t | | w		e: setup byte[dbase + rfvar]
		shl	x,#1		'| | | | | | | | | | | l m n | | | | | | | v |		f: setup byte[pbase + rfvar][pop index]
		add	ad,x		'| | | | | f g h | | | l m n | | | r s t u v w		g: setup byte[vbase + rfvar][pop index]
		shl	ad,#2		'a b | | | | | | | | | | | | | | | | | | | | |		h: setup byte[dbase + rfvar][pop index]
					'							i: setup word[pbase + rfvar]
		add	ad,pbase	'| | c | | f | | i | | l | | o | | r | | | | |		j: setup word[vbase + rfvar]
		add	ad,vbase	'a | | d | | g | | j | | m | | p | | s | | | |		k: setup word[dbase + rfvar]
		add	ad,dbase	'| b | | e | | h | | k | | n | | q | | t | | |		l: setup word[pbase + rfvar][pop index]
					'							m: setup word[vbase + rfvar][pop index]
hub_p		mov	ad,x		'| | | | | | | | | | | | | | | | | | | | | | | x y z	n: setup word[dbase + rfvar][pop index]
		popa	x		'| | | | | f g h | | | l m n | | | r s t u v w x y z	o: setup long[pbase + rfvar]
					'							p: setup long[vbase + rfvar]
		mov	rd,rd_byte	'| | c d e f g h | | | | | | | | | | | | u | | x | |	q: setup long[dbase + rfvar]
		mov	rd,rd_word	'| | | | | | | | i j k l m n | | | | | | | v | | y |	r: setup long[pbase + rfvar][pop index]
		mov	rd,rd_long	'a b | | | | | | | | | | | | o p q r s t | | w | | z	s: setup long[vbase + rfvar][pop index]
					'							t: setup long[dbase + rfvar][pop index]
		mov	wr,wr_byte	'| | c d e f g h | | | | | | | | | | | | u | | x | |	u: setup byte[pop base][pop index]
		mov	wr,wr_word	'| | | | | | | | i j k l m n | | | | | | | v | | y |	v: setup word[pop base][pop index]
		mov	wr,wr_long	'a b | | | | | | | | | | | | o p q r s t | | w | | z	w: setup long[pop base][pop index]
					'							x: setup byte[pop address]
		mov	sz,#7		'| | c d e f g h | | | | | | | | | | | | u | | x | |	y: setup word[pop address]
		mov	sz,#15		'| | | | | | | | i j k l m n | | | | | | | v | | y |	z: setup long[pop address]
		mov	sz,#31		'a b | | | | | | | | | | | | o p q r s t | | w | | z

	_ret_	setq2	#$0E1		'a b c d e f g h i j k l m n o p q r s t u v w x y z	(next bytecode is a variable operator)
'
'
' Setup hub structure variable		(24 longs)
'
hub_sv		rfvar	y		'a b c d	get starting offset << 4 | %wwii
		getnib	z,y,#0		'a b c d	isolate %wwii
		shr	y,#4		'a b c d	isolate starting offset
		pusha	x		'a b c |	a: setup [pbase + rfvar {+pop*rfvar}]
		mov	x,pbase		'a | | |	b: setup [vbase + rfvar {+pop*rfvar}]
		mov	x,vbase		'| b | |	c: setup [dbase + rfvar {+pop*rfvar}]
		mov	x,dbase		'| | c |	d: setup [pop   + rfvar {+pop*rfvar}]
		add	x,y		'a b c d	add starting offset before indexes

		mov	y,z				'get %ii index count
		and	y,#%11		wz		'0..3 = index count

	if_nz	rep	#4,y				'handle any indexes
	if_nz	popa	v				'pop stack to get index
	if_nz	rfvar	w				'get structure size
	if_nz	mul	v,w				'multiply index by structure size
	if_nz	add	x,v				'add into address

		shr	z,#2		wz		'get %ww word size, 0..3 = other/byte/word/long

	if_nz	add	z,#bc_setup_byte_pa & $1FF - 1	'if byte/word/long, get setup bytecode
	if_nz	rdlut	z,z				'look up execf value
	if_nz	execf	z				'chain to setup byte/word/long[pop address]

		rfbyte	y		wcz		'not byte/word/long, get address/push/pop command

	if_z	ret					'if address (y=0), return structure address on stack

		getptr	pb				'get updated bytecode pointer
	if_c	jmp	#structpush			'push structure (y=$80 | byte count)
		jmp	#structpop			'pop structure (y=byte count, C=0, Z=0)
'
'
' Setup bitfield			(14 longs)
' Set ++/-- value
'
bit_imm		mov	fb,pa		'a		a: setup bitfield [0..31]
		and	fb,#$1F		'a		b: setup bitfield [rfvar]
					'		c: setup bitfield [pop]
bit_rfvar	rfvar	fb		'| b		d: set ++/-- value

bit_pop		mov	fb,x		'| | c
		popa	x		'| | c

		mov	sz,fb		'a b c
		shr	sz,#5		'a b c

		mov	rdf,rd		'a b c
		mov	wrf_rd,rd	'a b c
		mov	wrf_wr,wr	'a b c

		mov	rd,rd_field	'a b c
		mov	wr,wr_field	'a b c

set_inc		rfvar	incdec		'| | | d

	_ret_	setq2	#$0E1		'a b c d	(next bytecode is a variable operator)
'
'
' Variable read/write			(10 longs)
'
var_rd		pusha	x		'a   c		a: read  long[dbase][0..15]
					'		b: write long[dbase][0..15]	(isolated)		
var_wr_im	getnib	ad,pa,#0	'a b |		c: read var		
		shl	ad,#2		'a b |		d: write var			(isolated)
		add	ad,dbase	'a b |		e: write var			(push)

		alti	rd		'| | c
	_ret_	rdlong	x,ad		'a | c

var_wr		alti	wr		'  | | d e
		wrlong	x,ad		'  b | d e

	_ret_	popa	x		'  b | d |
	_ret_	zerox	x,sz		'    c   e	(ret for c, ret+zerox for e)
'
'
' Variable operator bytecodes at $279 - triggered via '_ret_ setq2 #$0E1'
'
altcodes
		orgf	$279

bc_set_incdec		long  set_inc	|                    %00 << 10	'79	set ++/--

bc_repeat_var_init_n	long  repvarin	|         %0111111100110 << 10	'7A Z=0	REPEAT-var init, 0..n-1
bc_repeat_var_init_1	long  repvari1	|                     %0 << 10	'7B	REPEAT-var init, step 1
bc_repeat_var_init	long  repvari	|                     %0 << 10	'7C	REPEAT-var init
bc_repeat_var_loop	long  repvarl	|                     %0 << 10	'7D	REPEAT-var loop

bc_get_field		long  var_ptr	|                    %00 << 10	'7E	^@anyvar
bc_get_addr		long  var_ptr	|                  %0010 << 10	'7F	@hubvar
bc_read			long  var_rd	|            %0111001110 << 10	'80	read var
bc_write		long  var_wr	|                     %0 << 10	'81	write var	(isolated)
bc_write_push		long  var_wr	|                  %0100 << 10	'82	write var	(push)

bc_var_inc		long  mod_iso	|     %00011111010110010 << 10	'83	++var, var++	(isolated)
bc_var_dec		long  mod_iso	|     %00011111001110010 << 10	'84	--var, var--	(isolated)
bc_var_preinc_push	long  mod_psh	|   %011001111001011000_ << 10	'85	++var		(push)
bc_var_predec_push	long  mod_psh	|   %011001111000111000_ << 10	'86	--var		(push)
bc_var_postinc_push	long  mod_psh	|    %01001111101001000_ << 10	'87	var++		(push)
bc_var_postdec_push	long  mod_psh	|    %01001111100101000_ << 10	'88	var--		(push)
bc_var_lognot		long  mod_iso	|     %00011011111110010 << 10	'89	var!!		(isolated)
bc_var_lognot_push	long  mod_psh	|    %01001101111101000_ << 10	'8A	var!!		(push)
bc_var_bitnot		long  mod_iso	|     %00010111111110010 << 10	'8B	var!		(isolated)
bc_var_bitnot_push	long  mod_psh	|    %01001011111101000_ << 10	'8C	var!		(push)
bc_var_swap		long  mod_iso	|    %010001111111010010 << 10	'8D	var\new		(swap)
bc_var_rnd		long  mod_iso	|     %00011111111000010 << 10	'8E	??var		(isolated)
bc_var_rnd_push		long  mod_psh	|    %01001111111100000_ << 10	'8F	??var		(push)

bc_lognot_write		long  una_iso	|  %00011111111011110010 << 10	'90	!!= var		(isolated)
bc_bitnot_write		long  una_iso	|  %00011111110111110010 << 10	'91	!= var		(isolated)
bc_neg_write		long  una_iso	|  %00011111101111110010 << 10	'92	-= var		(isolated)
bc_abs_write		long  una_iso	|  %00011111011111110010 << 10	'93	ABS= var	(isolated)
bc_encod_write		long  una_iso	|  %00011110111111110010 << 10	'94	ENCOD= var	(isolated)
bc_decod_write		long  una_iso	|  %00011101111111110010 << 10	'95	DECOD= var	(isolated)
bc_bmask_write		long  una_iso	|  %00011011111111110010 << 10	'96	BMASK= var	(isolated)
bc_ones_write		long  una_iso	|  %00010111111111110010 << 10	'97	ONES= var	(isolated)
bc_sqrt_write		long  una_iso	|  %00001111111111000010 << 10	'98	SQRT= var	(isolated)
bc_qlog_write		long  una_iso	|  %00001111111110100010 << 10	'99	QLOG= var	(isolated)
bc_qexp_write		long  una_iso	|  %00001111111101100010 << 10	'9A	QEXP= var	(isolated)

bc_shr_write		long  sha_mod	|       %000111110110010 << 10	'9B	var >>= exp	(isolated)
bc_shl_write		long  sha_mod	|       %000111111010010 << 10	'9C	var <<= exp	(isolated)
bc_sar_write		long  sha_mod	|       %000111101110010 << 10	'9D	var SAR= exp	(isolated)
bc_ror_write		long  sha_mod	|       %000111011110010 << 10	'9E	var ROR= exp	(isolated)
bc_rol_write		long  sha_mod	|       %000110111110010 << 10	'9F	var ROL= exp	(isolated)
bc_rev_write		long  rev_mod	|       %00011111010000_ << 10	'A0	var REV= exp	(isolated)
bc_zerox_write		long  rev_mod	|       %00011111001000_ << 10	'A1	var ZEROX= exp	(isolated)
bc_signx_write		long  rev_mod	|       %00011110101000_ << 10	'A2	var SIGNX= exp	(isolated)
bc_add_write		long  sha_mod	|       %000101111110010 << 10	'A3	var += exp	(isolated)
bc_sub_write		long  sha_mod	|       %000011111110010 << 10	'A4	var -= exp	(isolated)

bc_logand_write		long  log_mod	|    %000111111000000___ << 10	'A5	var &&= exp	(isolated)
bc_logxor_write		long  log_mod	|    %000111110100000___ << 10	'A6	var ^^= exp	(isolated)
bc_logor_write		long  log_mod	|    %000110111100000___ << 10	'A7	var ||= exp	(isolated)
bc_bitand_write		long  log_mod	|    %000111111010010___ << 10	'A8	var &= exp	(isolated)
bc_bitxor_write		long  log_mod	|    %000111110110010___ << 10	'A9	var ^= exp	(isolated)
bc_bitor_write		long  log_mod	|    %000110111110010___ << 10	'AA	var |= exp	(isolated)
bc_fge_write		long  log_mod	|    %000101111110010___ << 10	'AB	var #>= exp	(isolated)
bc_fle_write		long  log_mod	|    %000011111110010___ << 10	'AC	var <#= exp	(isolated)
bc_addbits_write	long  add_mod	|    %000110101110010100 << 10	'AD	var ADDBITS exp	(isolated)
bc_addpins_write	long  add_mod	|    %000110011110010010 << 10	'AE	var ADDPINS exp	(isolated)

bc_mul_write		long  muu_mod	|   %000111110110011000_ << 10	'AF	var *= exp	(isolated)
bc_div_write		long  mul_mod	|   %0001111001010000010 << 10	'B0	var /= exp	(isolated)
bc_divu_write		long  muu_mod	|   %000111110101011000_ << 10	'B1	var +/= exp	(isolated)
bc_rem_write		long  mul_mod	|   %0001100111010000010 << 10	'B2	var //= exp	(isolated)
bc_remu_write		long  muu_mod	|   %000111011101011000_ << 10	'B3	var +//= exp	(isolated)
bc_sca_write		long  muu_mod	|   %000111011110011000_ << 10	'B4	var SCA= exp	(isolated)
bc_scas_write		long  mul_mod	|   %0000010111100000010 << 10	'B5	var SCAS= exp	(isolated)
bc_frac_write		long  muu_mod	|   %000111110011011000_ << 10	'B6	var FRAC= exp	(isolated)

bc_lognot_write_push	long  una_psh	|  %01001111111101111000 << 10	'B7	!!= var		(push)
bc_bitnot_write_push	long  una_psh	|  %01001111111011111000 << 10	'B8	!= var		(push)
bc_neg_write_push	long  una_psh	|  %01001111110111111000 << 10	'B9	-= var		(push)
bc_abs_write_push	long  una_psh	|  %01001111101111111000 << 10	'BA	ABS= var	(push)
bc_encod_write_push	long  una_psh	|  %01001111011111111000 << 10	'BB	ENCOD= var	(push)
bc_decod_write_push	long  una_psh	|  %01001110111111111000 << 10	'BC	DECOD= var	(push)
bc_bmask_write_push	long  una_psh	|  %01001101111111111000 << 10	'BD	BMASK= var	(push)
bc_ones_write_push	long  una_psh	|  %01001011111111111000 << 10	'BE	ONES= var	(push)
bc_sqrt_write_push	long  una_psh	|  %01000111111111100000 << 10	'BF	SQRT= var	(push)
bc_qlog_write_push	long  una_psh	|  %01000111111111010000 << 10	'C0	QLOG= var	(push)
bc_qexp_write_push	long  una_psh	|  %01000111111110110000 << 10	'C1	QEXP= var	(push)

bc_shr_write_push	long  sha_mod	|      %0100111110110010 << 10	'C2	var >>= exp	(push)
bc_shl_write_push	long  sha_mod	|      %0100111111010010 << 10	'C3	var <<= exp	(push)
bc_sar_write_push	long  sha_mod	|      %0100111101110010 << 10	'C4	var SAR= exp	(push)
bc_ror_write_push	long  sha_mod	|      %0100111011110010 << 10	'C5	var ROR= exp	(push)
bc_rol_write_push	long  sha_mod	|      %0100110111110010 << 10	'C6	var ROL= exp	(push)
bc_rev_write_push	long  rev_mod	|      %010011111010000_ << 10	'C7	var REV= exp	(push)
bc_zerox_write_push	long  rev_mod	|      %010011111001000_ << 10	'C8	var ZEROX= exp	(push)
bc_signx_write_push	long  rev_mod	|      %010011110101000_ << 10	'C9	var SIGNX= exp	(push)
bc_add_write_push	long  sha_mod	|      %0100101111110010 << 10	'CA	var += exp	(push)
bc_sub_write_push	long  sha_mod	|      %0100011111110010 << 10	'CB	var -= exp	(push)

bc_logand_write_push	long  log_mod	|   %0100111111000000___ << 10	'CC	var &&= exp	(push)
bc_logxor_write_push	long  log_mod	|   %0100111110100000___ << 10	'CD	var ^^= exp	(push)
bc_logor_write_push	long  log_mod	|   %0100110111100000___ << 10	'CE	var ||= exp	(push)
bc_bitand_write_push	long  log_mod	|   %0100111111010010___ << 10	'CF	var &= exp	(push)
bc_bitxor_write_push	long  log_mod	|   %0100111110110010___ << 10	'D0	var ^= exp	(push)
bc_bitor_write_push	long  log_mod	|   %0100110111110010___ << 10	'D1	var |= exp	(push)
bc_fge_write_push	long  log_mod	|   %0100101111110010___ << 10	'D2	var #>= exp	(push)
bc_fle_write_push	long  log_mod	|   %0100011111110010___ << 10	'D3	var <#= exp	(push)
bc_addbits_write_push	long  add_mod	|   %0100110101110010100 << 10	'D4	var ADDBITS exp	(push)
bc_addpins_write_push	long  add_mod	|   %0100110011110010010 << 10	'D5	var ADDPINS exp	(push)

bc_mul_write_push	long  muu_mod	|  %0100111110110011000_ << 10	'D6	var *= exp	(push)
bc_div_write_push	long  mul_mod	|  %01001111001010000010 << 10	'D7	var /= exp	(push)
bc_divu_write_push	long  muu_mod	|  %0100111110101011000_ << 10	'D8	var +/= exp	(push)
bc_rem_write_push	long  mul_mod	|  %01001100111010000010 << 10	'D9	var //= exp	(push)
bc_remu_write_push	long  muu_mod	|  %0100111011101011000_ << 10	'DA	var +//= exp	(push)
bc_sca_write_push	long  muu_mod	|  %0100111011110011000_ << 10	'DB	var SCA= exp	(push)
bc_scas_write_push	long  mul_mod	|  %01000010111100000010 << 10	'DC	var SCAS= exp	(push)
bc_frac_write_push	long  muu_mod	|  %0100111110011011000_ << 10	'DD	var FRAC= exp	(push)

bc_setup_bfield_pop	long  bit_pop	|           %01000000000 << 10	'DE *	setup bitfield .[pop]
bc_setup_bfield_rfvar	long  bit_rfvar	|          %010000000110 << 10	'DF *	setup bitfield .[rfvar]

'bytecodes Ex/Fx are collapsed at runtime to LUT entries E0/E1

bc_setup_bfield_0_31	long  bit_imm	|         %01000000011100 << 10	'Ex *	setup bitfield .[0..15]
			long  bit_imm	|         %01000000011100 << 10	'Fx *	setup bitfield .[16..31]
'
'
' Add pbase to x			(1 long)
'
addbase	_ret_	add	x,pbase
'
'
' Constants				(13 longs)
'
const		pusha	x		'a b c d e f g h i j	a: constant -1..14
		mov	x,pa		'a | | | | | | | | |	b: byte
	_ret_	sub	x,#bc_con_n-$2FF'a | | | | | | | | |	c: byte!
	_ret_	rfbyte	x		'  b | | | | | | | |	d: word
		rfbyte	x		'    c | | | g h i j	e: word!
	_ret_	rfword	x		'    | d | | | | | |	f: long
		rfword	x		'    |   e | | | | |	g: byte + decod
	_ret_	rflong	x		'    |   | f | | | |	h: byte + decod + not
	_ret_	decod	x		'    |   |   g | | |	i: byte + bmask
		decod	x		'    |   |     h | |	j: byte + bmask + not
	_ret_	bmask	x		'    |   |     | i |
		bmask	x		'    |   |     |   j
	_ret_	not	x		'    c   e     h   j
'
'
' Miscellaneous				(16 longs)
'
pop2		mov	w,x		'  b c d e f		a: CASE done
cased		setq	#2-1		'a b c d e f		b: WRPIN(pins,val)
		rdlong	x,--ptra	'a b c d e f		c: WXPIN(pins,val)
		add	y,pbase		'a | | | | |		d: WYPIN(pins,val)
	_ret_	rdfast	#0,y		'a | | | | |		e: COGINIT(cog,pgm,ptr)	(push)
	_ret_	wrpin	w,y		'  b | | | |		f: COGINIT(cog,pgm,ptr)
	_ret_	wxpin	w,y		'    c | | |		g: COGSTOP(cog)
	_ret_	wypin	w,y		'      d | |		h: LOCKRET(lock)
		setq	w		'        e f		i: LOCKREL(lock)
		coginit	x,y	wc	'        e f		j: COGATN(mask)
	_ret_	bitc	x,#31		'        e |
cogstop_	cogstop	x		'          | g
lockret_	lockret	x		'          | | h
lockrel_	lockrel	x		'          | | | i
cogatn_		cogatn	x		'          | | | | j
	_ret_	popa	x		'          f g h i j
'
'
' Main bytecodes at $300
'
maincodes
		orgf	$300

bc_drop			long  drop	|                     %0 << 10	'00	drop anchor	(0..3)
bc_drop_push		long  drop	|                     %0 << 10	'01	drop anchor, push
bc_drop_trap		long  drop	|                     %0 << 10	'02	drop anchor, trap
bc_drop_trap_push	long  drop	|                     %0 << 10	'03	drop anchor, trap, push

bc_return_results	long  return_	|                     %0 << 10	'04 Z=0	RETURN
bc_return_args		long  return_	|                     %0 << 10	'05 Z=1	RETURN x,y,z...

bc_abort_0		long  abort_	|                     %0 << 10	'06 Z=0	ABORT
bc_abort_arg		long  abort_	|                     %0 << 10	'07 Z=1	ABORT x

bc_call_obj_sub		long  callobj	|         %01000010_0000 << 10	'08	call obj.sub
bc_call_obji_sub	long  callobj	|      %01001000000_0000 << 10	'09	call obj[].sub
bc_call_sub		long  callsub	|               %0_0100_ << 10	'0A	call sub
bc_call_ptr		long  callptr	|                     %0 << 10	'0B	call ptr()
bc_call_recv		long  callrecv	|                     %0 << 10	'0C	call RECV()
bc_call_send		long  callsend	|                     %0 << 10	'0D	call SEND(x)
bc_call_send_bytes	long  callobj	|             %011111010 << 10	'0E	call SEND(bytes...)

bc_mptr_obj_sub		long  callobj	|    %01100_0000010_0000 << 10	'0F	@obj.sub	(push)
bc_mptr_obji_sub	long  callobj	|    %01110_0000000_0000 << 10	'10	@obj[].sub	(push)
bc_mptr_sub		long  callsub	|          %0111110_000_ << 10	'11	@sub		(push)

bc_jmp			long  branch	|         %0111101111110 << 10	'12	jmp  rfvars
bc_jz			long  branch	|         %0111101110000 << 10	'13	jz   rfvars
bc_jnz			long  branch	|         %0111100111000 << 10	'14	jnz  rfvars
bc_tjz			long  branch	|         %0111101010100 << 10	'15	tjz  rfvars
bc_djnz			long  branch	|         %0111100001110 << 10	'16	djnz rfvars

bc_pop			long  pop1	|                     %0 << 10	'17	pop
bc_pop_rfvar		long  popx	|              %01111100 << 10	'18	pop rfvar

bc_hub_bytecode		long  hub_code	|                     %0 << 10	'19	hub bytecode rfbyte

bc_case_fast_init	long  casefi	|        %01010000000000 << 10	'1A	CASE_FAST init
bc_case_fast_done	long  casefd	|                     %0 << 10	'1B	CASE_FAST done

bc_case_value		long  casev	|                     %0 << 10	'1C	CASE value
bc_case_range		long  range	|         %0110110000000 << 10	'1D	CASE value1..value2
bc_case_done		long  cased	|                  %0000 << 10	'1E	CASE done

bc_lookup_value		long  lookv	|              %00001000 << 10	'1F C=1	LOOKUP  (target : ,,value,,)
bc_lookdown_value	long  lookv	|              %00000100 << 10	'20 C=0	LOOKDOWN(target : ,,value,,)
bc_lookup_range		long  range	|%1100111111000000111100 << 10	'21	LOOKUP  (target : ,,value1..value2,,)
bc_lookdown_range	long  range	|%0011110000110000011100 << 10	'22	LOOKDOWN(target : ,,value1..value2,,)
bc_look_done		long  lookd	|               %0111110 << 10	'23 C=1	LOOKUP/LOOKDOWN done

bc_add_pbase		long  addbase	|                     %0 << 10	'24	add pbase to x

bc_coginit		long  pop2	|      %0111110011111000 << 10	'25	COGINIT(cog,pgm,ptr)
bc_coginit_push		long  pop2	|           %00011111000 << 10	'26	COGINIT(cog,pgm,ptr)	(push)
bc_cogstop		long  cogstop_	|                 %01110 << 10	'27	COGSTOP(cog)
bc_cogid		long  pushv	|                 %01110 << 10	'28	COGID()		(push)

bc_locknew		long  pushv	|         %0111111011110 << 10	'29	LOCKNEW()	(push)
bc_lockret		long  lockret_	|                  %0110 << 10	'2A	LOCKRET(lock)
bc_locktry		long  locktry_	|                    %00 << 10	'2B	LOCKTRY(lock)	(push)
bc_lockrel		long  lockrel_	|                   %010 << 10	'2C	LOCKREL(lock)
bc_lockchk		long  lockchk_	|                  %0110 << 10	'2D	LOCKCHK(lock)	(push)

bc_cogatn		long  cogatn_	|                    %00 << 10	'2E	COGATN(mask)
bc_pollatn		long  pushv	|       %011111110111110 << 10	'2F	POLLATN()	(push)
bc_waitatn		long  waitatn_	|                   %000 << 10	'30	WAITATN()

bc_getrnd		long  pushv	|                   %010 << 10	'31	GETRND()	(push)
bc_getct		long  pushv	|                  %0110 << 10	'32	GETCT()		(push)
bc_pollct		long  pwct	|           %01111111100 << 10	'33	POLLCT(tick)	(push)
bc_waitct		long  pwct	|                     %0 << 10	'34	WAITCT(tick)

bc_pinlow		long  pinl_	|                %011110 << 10	'35	PINLOW(pins)
bc_pinhigh		long  pinh_	|                 %01110 << 10	'36	PINHIGH(pins)
bc_pintoggle		long  pint_	|                  %0110 << 10	'37	PINTOGGLE(pins)
bc_pinfloat		long  pinf_	|                   %010 << 10	'38	PINFLOAT(pins)

bc_wrpin		long  pop2	|                %011000 << 10	'39	WRPIN(pins,val)
bc_wxpin		long  pop2	|               %0111000 << 10	'3A	WXPIN(pins,val)
bc_wypin		long  pop2	|              %01111000 << 10	'3B	WYPIN(pins,val)
bc_akpin		long  akpin_	|                    %00 << 10	'3C	AKPIN(pins)
bc_rdpin		long  rdpin_	|                   %010 << 10	'3D	RDPIN(pin)	(push)
bc_rqpin		long  rqpin_	|                    %00 << 10	'3E	RQPIN(pin)	(push)

bc_unused_3F		long  0		|                     %0 << 10	'3F	<unused>
bc_unused_40		long  0		|                     %0 << 10	'40	<unused>

bc_debug		long  debug_	|          %000111111000 << 10	'41	DEBUG() rfvar,rfbyte

bc_con_rfbyte		long  const	|                  %0110 << 10	'42	constant rfbyte
bc_con_rfbyte_not	long  const	|         %0111111101110 << 10	'43	constant rfbyte!
bc_con_rfword		long  const	|                %011110 << 10	'44	constant rfword
bc_con_rfword_not	long  const	|         %0111110111110 << 10	'45	constant rfword!
bc_con_rflong		long  const	|              %01111110 << 10	'46	constant rflong
bc_con_rfbyte_decod	long  const	|             %011101110 << 10	'47	constant rfbyte + decod
bc_con_rfbyte_decod_not	long  const	|         %0110111101110 << 10	'48	constant rfbyte + decod + not
bc_con_rfbyte_bmask	long  const	|           %01111101110 << 10	'49	constant rfbyte + bmask
bc_con_rfbyte_bmask_not	long  const	|         %0011111101110 << 10	'4A	constant rfbyte + bmask + not

bc_setup_field_p	long  field_	|                     %0 << 10	'4B *	setup field[pop field]
bc_setup_field_pi	long  fieldi_	|                     %0 << 10	'4C *	setup field[pop field][pop index]

bc_setup_reg		long  reg_ap	|                  %0110 << 10	'4D *	setup reg[rfvars]
bc_setup_reg_pi		long  reg_ap	|                     %0 << 10	'4E *	setup reg[rfvars][pop index]

bc_setup_byte_pbase	long  hub_ap	| %011011011011110111110 << 10	'4F *	setup byte[pbase + rfvar]
bc_setup_byte_vbase	long  hub_ap	| %011011011011101111110 << 10	'50 *	setup byte[vbase + rfvar]
bc_setup_byte_dbase	long  hub_ap	| %011011011011011111110 << 10	'51 *	setup byte[dbase + rfvar]
bc_setup_byte_pbase_pi	long  hub_ap	| %011011011001110101110 << 10	'52 *	setup byte[pbase + rfvar][pop index]
bc_setup_byte_vbase_pi	long  hub_ap	| %011011011001101101110 << 10	'53 *	setup byte[vbase + rfvar][pop index]
bc_setup_byte_dbase_pi	long  hub_ap	| %011011011001011101110 << 10	'54 *	setup byte[dbase + rfvar][pop index]

bc_setup_word_pbase	long  hub_ap	| %010110110111110111110 << 10	'55 *	setup word[pbase + rfvar]
bc_setup_word_vbase	long  hub_ap	| %010110110111101111110 << 10	'56 *	setup word[vbase + rfvar]
bc_setup_word_dbase	long  hub_ap	| %010110110111011111110 << 10	'57 *	setup word[dbase + rfvar]
bc_setup_word_pbase_pi	long  hub_ap	| %010110110101110100110 << 10	'58 *	setup word[pbase + rfvar][pop index]
bc_setup_word_vbase_pi	long  hub_ap	| %010110110101101100110 << 10	'59 *	setup word[vbase + rfvar][pop index]
bc_setup_word_dbase_pi	long  hub_ap	| %010110110101011100110 << 10	'5A *	setup word[dbase + rfvar][pop index]

bc_setup_long_pbase	long  hub_ap	| %001101101111110111110 << 10	'5B *	setup long[pbase + rfvar]
bc_setup_long_vbase	long  hub_ap	| %001101101111101111110 << 10	'5C *	setup long[vbase + rfvar]
bc_setup_long_dbase	long  hub_ap	| %001101101111011111110 << 10	'5D *	setup long[dbase + rfvar]
bc_setup_long_pbase_pi	long  hub_ap	| %001101101101110101010 << 10	'5E *	setup long[pbase + rfvar][pop index]
bc_setup_long_vbase_pi	long  hub_ap	| %001101101101101101010 << 10	'5F *	setup long[vbase + rfvar][pop index]
bc_setup_long_dbase_pi	long  hub_ap	| %001101101101011101010 << 10	'60 *	setup long[dbase + rfvar][pop index]

bc_setup_byte_pa	long  hub_p	|          %011011011000 << 10	'61 *	setup byte[pop address]
bc_setup_word_pa	long  hub_p	|          %010110110100 << 10	'62 *	setup word[pop address]
bc_setup_long_pa	long  hub_p	|          %001101101100 << 10	'63 *	setup long[pop address]

bc_setup_byte_pb_pi	long  hub_pp	|  %01101101100111110110 << 10	'64 *	setup byte[pop base][pop index]
bc_setup_word_pb_pi	long  hub_pp	|  %01011011010111110010 << 10	'65 *	setup word[pop base][pop index]
bc_setup_long_pb_pi	long  hub_pp	|  %00110110110111110100 << 10	'66 *	setup long[pop base][pop index]

bc_setup_struct_pbase	long  hub_sv	|              %01100000 << 10	'67	setup [pbase + rfvar {+pop*rfvar}]
bc_setup_struct_vbase	long  hub_sv	|              %01010000 << 10	'68	setup [vbase + rfvar {+pop*rfvar}]
bc_setup_struct_dbase	long  hub_sv	|              %00110000 << 10	'69	setup [dbase + rfvar {+pop*rfvar}]
bc_setup_struct_pop	long  hub_sv	|              %01111000 << 10	'6A	setup [pop   + rfvar {+pop*rfvar}]

bc_ternary		long  ternary	|                  %0000 << 10	'6B	x ? y : z

bc_lt			long  op_rel	|               %0111100 << 10	'6C	exp <   exp
bc_ltu			long  op_rel	|               %0110110 << 10	'6D	exp +<  exp
bc_lte			long  op_rel	|                %011010 << 10	'6E	exp <=  exp
bc_lteu			long  op_rel	|                %001110 << 10	'6F	exp +<= exp
bc_e			long  op_rel	|             %011111100 << 10	'70	exp ==  exp
bc_ne			long  op_rel	|              %01111100 << 10	'71	exp <>  exp
bc_gte			long  op_rel	|                %011100 << 10	'72	exp >=  exp
bc_gteu			long  op_rel	|                %010110 << 10	'73	exp +>= exp
bc_gt			long  op_rel	|               %0111010 << 10	'74	exp >   exp
bc_gtu			long  op_rel	|               %0101110 << 10	'75	exp +>  exp
bc_ltegt		long  op_rel	|           %00111111100 << 10	'76	exp <=> exp

bc_lognot		long  op_notb	|      %0111111111011110 << 10	'77	!!exp		(NOT exp)
bc_bitnot		long  op_not	|      %0111111110______ << 10	'78	!exp
bc_neg			long  op_neg	|      %011111110_______ << 10	'79	-exp
bc_abs			long  op_abs	|      %01111110________ << 10	'7A	ABS exp
bc_encod		long  op_encod	|      %0111110_________ << 10	'7B	ENCOD exp
bc_decod		long  op_decod	|      %011110__________ << 10	'7C	DECOD exp
bc_bmask		long  op_bmask	|      %01110___________ << 10	'7D	BMASK exp
bc_ones			long  op_ones	|      %0110____________ << 10	'7E	ONES exp
bc_sqrt			long  op_quna	|      %010111111111100_ << 10	'7F	SQRT exp
bc_qlog			long  op_quna	|      %010111111111010_ << 10	'80	QLOG exp
bc_qexp			long  op_quna	|      %010111111110110_ << 10	'81	QEXP exp

bc_shr			long  sha_mod	|        %01111110110110 << 10	'82	exp >> exp
bc_shl			long  sha_mod	|        %01111111010110 << 10	'83	exp << exp
bc_sar			long  sha_mod	|        %01111101110110 << 10	'84	exp SAR exp
bc_ror			long  sha_mod	|        %01111011110110 << 10	'85	exp ROR exp
bc_rol			long  sha_mod	|        %01110111110110 << 10	'86	exp ROL exp
bc_rev			long  rev_mod	|        %0111111010010_ << 10	'87	exp REV exp
bc_zerox		long  rev_mod	|        %0111111001010_ << 10	'88	exp ZEROX exp
bc_signx		long  rev_mod	|        %0111110101010_ << 10	'89	exp SIGNX exp
bc_add			long  sha_mod	|        %01101111110110 << 10	'8A	exp + exp
bc_sub			long  sha_mod	|        %01011111110110 << 10	'8B	exp - exp

bc_logand		long  log_mod	|     %01111111000100___ << 10	'8C	exp && exp	(exp AND exp)
bc_logxor		long  log_mod	|     %01111110100100___ << 10	'8D	exp ^^ exp	(exp XOR exp)
bc_logor		long  log_mod	|     %01110111100100___ << 10	'8E	exp || exp	(exp OR exp)
bc_bitand		long  log_mod	|     %01111111010110___ << 10	'8F	exp & exp
bc_bitxor		long  log_mod	|     %01111110110110___ << 10	'90	exp ^ exp
bc_bitor		long  log_mod	|     %01110111110110___ << 10	'91	exp | exp
bc_fge			long  log_mod	|     %01101111110110___ << 10	'92	exp #> exp
bc_fle			long  log_mod	|     %01011111110110___ << 10	'93	exp <# exp
bc_addbits		long  add_mod	|     %01110101110110100 << 10	'94	var ADDBITS exp
bc_addpins		long  add_mod	|     %01110011110110010 << 10	'95	var ADDPINS exp

bc_mul			long  muu_mod	|    %01111110110011010_ << 10	'96	exp * exp
bc_div			long  mul_mod	|    %011111001010000110 << 10	'97	exp / exp
bc_divu			long  muu_mod	|    %01111110101011010_ << 10	'98	exp +/ exp
bc_rem			long  mul_mod	|    %011100111010000110 << 10	'99	exp // exp
bc_remu			long  muu_mod	|    %01111011101011010_ << 10	'9A	exp +// exp
bc_sca			long  muu_mod	|    %01111011110011010_ << 10	'9B	exp SCA exp
bc_scas			long  mul_mod	|    %010010111100000110 << 10	'9C	exp SCAS exp
bc_frac			long  muu_mod	|    %01111110011011010_ << 10	'9D	exp FRAC exp

bc_string		long  string_	|    %011110111111100010 << 10	'9E	STRING()
bc_bitrange		long  bitrange	|                 %00110 << 10	'9F	bitrange

'bytecodes Ax/Bx/Cx/Dx/Ex/Fx are collapsed at runtime to LUT entries A0/A1/A2/A3/A4/A5

bc_con_n		long  const	|                   %000 << 10	'Ax	constant -1..14
bc_setup_reg_1D8_1F8_	long  reg_im	|                %011100 << 10	'Bx *	setup reg $1D8..$1DF/$1F8..$1FF
bc_setup_var_0_15_	long  hub_im	|  %11011011111010111110 << 10	'Cx *	setup long[vbase][0..15]
bc_setup_local_0_15_	long  hub_im	|  %11011011110110111110 << 10	'Dx *	setup long[dbase][0..15]
bc_read_local_0_15_	long  var_rd	|                %010000 << 10	'Ex	read  long[dbase][0..15]
bc_write_local_0_15_	long  var_wr_im	|               %0111000 << 10	'Fx	write long[dbase][0..15]  (isolated)

					'* must end in '_ret_ setq2 #$0E1' to invoke variable operator bytecodes
'
'
' RETURN				(1 long)
'
return_		jmp	#returnh	'continue in hub
'
'
' ABORT					(1 long)
'
abort_		jmp	#aborth		'continue in hub
'
'
' Setup field variable			(1 long)
'
field_		jmp	#fieldh		'continue in hub
'
'
' Setup field variable with index	(1 long)
'
fieldi_		jmp	#fieldih	'continue in hub
'
'
' a: ^@anyvar				(4 longs)
' b: @hubvar
'
var_ptr		pusha	x		'a b
		jmp	#mfieldh	'a |
		mov	x,ad		'  b
	_ret_	zerox	x,#19		'  b
'
'
' Miscellaneous				(19 longs)
'
ternary		setq	#2-1		'a			a: ternary (y ? z : x)
bitrange	rdlong	y,--ptra	'a b			b: bitrange (top,bottom --> bottom,top-bottom)
	_ret_	tjnz	y,#.true	'a |			c: GETRND()
.true	_ret_	mov	x,z		'a |			d: GETCT()
pushv		pusha	x		'  b c d e f g		e: COGID()
	_ret_	subr	x,y		'  b | | | | |		f: LOCKNEW()
	_ret_	getrnd	x		'    c | | | |		g: POLLATN()
	_ret_	getct	x		'      d | | |		h: WAITATN()
	_ret_	cogid	x		'        e | |		i: LOCKCHK(lock)
		locknew	x	wc	'          f |		j: RDPIN(pin)
waitatn_	pollatn		wc	'          | g h	k: RQPIN(pin)
	if_nc	jmp	#waitatn_	'          | | h	l: LOCKTRY(lock)
		ret			'          | | h
lockchk_	lockrel	x	wc	'          | |   i
rdpin_		rdpin	x,x	wc	'          | |   | j
rqpin_		rqpin	x,x	wc	'          | |   | | k
	_ret_	bitc	x,#31		'          f |   i j k
locktry_	locktry	x	wc	'            |         l
	_ret_	muxc	x,_FFFFFFFF	'            g         l
'
'
' a: POLLCT(tick)			(16 longs)
' b: LOOKUP/LOOKDOWN done
' n: WAITCT(tick)
'
pwct		getct	w		'a   n		a: POLLCT(tick)
		cmpm	w,x	wc	'a   n		b: LOOKUP/LOOKDOWN done
	if_c	jmp	#pwct		'|   n		n: WAITCT(tick)
	_ret_	popa	x		'|   n
lookd		sub	ptra,#2*4	'| b		(continued in op_rel)
'
'
' Relational operators
'
op_rel		popa	w		'| | c d e f g h i j k l m	c: <
		cmps	w,x	wcz	'| | c | | | g h i | | | m	d: +<
		cmps	x,w	wcz	'| | | | e | | | | | k | |	e: <=
		cmp	w,x	wcz	'| | | d | | | | | j | | |	f: +<=
		cmp	x,w	wcz	'| | | | | f | | | | | l |	g: ==
	_ret_	muxnc	x,_FFFFFFFF	'a b | | e f | | i j | | |	h: <>
	_ret_	muxc	x,_FFFFFFFF	'    c d     | |     k l |	i: >=
	_ret_	muxnz	x,_FFFFFFFF	'            | h         |	j: +>=
	_ret_	muxz	x,_FFFFFFFF	'            g           |	k: >
		muxc	x,_FFFFFFFF	'                        m	l: +>
	_ret_	muxnz	x,#1		'                        m	m: <=>
'
'
' a: CASE_FAST init			(4 longs)
'
' entry:
'
'   x		index
'   ptra[-1]	address
'
' exit:
'
'   x		address
'
'
' b: CASE_FAST done
'
' entry:
'
'   x		address
'
casefi		rflong	v		'a	get index base
		rfword	w		'a	get index limiter
		jmp	#casefih	'a	continue in hub

casefd		jmp	#casefdh	'  b	continue in hub
'
'
' CASE value				(9 longs)
'
' entry:
'
'   x		value
'   ptra[-1]	target
'   ptra[-2]	address
'
' exit:
'
'   x		target
'   ptra[-1]	address
'
'
casev		rfvar	a		'read address

		mov	w,x		'value into w
		popa	x		'pop target into x
		sub	w,x	wz	'value = target?
	if_nz	ret			'exit if not equal

reljmp		add	a,pb		'add relative address
	_ret_	rdfast	#0,a		'branch

absjmp		add	a,pbase		'add pbase
	_ret_	rdfast	#0,a		'branch to case code
'
'
' a: LOOKUP(target : ,,,value,,,)	C=1	(8 longs)
'
'  if index == target
'    result := value
'    branch to address
'  else index++
'
'
' b: LOOKDOWN(target : ,,,value,,,)	C=0
'
'  if value == target
'    result := index
'    branch to address
'  else index++
'
'
'  x		value		x
'  ptra[-1]	index		c
'  ptra[-2]	target		b
'  ptra[-3]	address		a
'
'
lookv		setq	#3-1		'a b	pop address/target/index into a/b/c
		rdlong	a,--ptra	'a b

		cmp	b,c	wz	'a |	index == target?
		cmp	b,x	wz	'| b	value == target?

  if_nc_or_nz	mov	x,c		'a b	if LOOKDOWN or not equal, get index on stack top

  if_z		jmp	#absjmp		'a b	if equal, branch to address

		add	ptra,#2*4	'a b	else, unpop address/target
  _ret_		add	x,#1		'a b	get index++ on stack top
'
'
' a: LOOKUP(target : ,,,value1..value2,,,)	(26 longs)
'
'  if value1 <= value2
'    delta = value2 - value1
'    if index <= target <= index + delta
'      result = value1 - index + target
'      branch to address
'    else index += delta + 1
'
'  if value1 > value2
'    delta = value1 - value2
'    if index <= target <= index + delta
'      result = value1 + index - target
'      branch to address
'    else index += delta + 1
'
' entry:
'
'  x		value2		x
'  ptra[-1]	value1		d
'  ptra[-2]	index		c
'  ptra[-3]	target		b
'  ptra[-4]	address		a
'
'
' b: LOOKDOWN(target : ,,,value1..value2,,,)
'
'  if value1 <= value2
'    delta = value2 - value1
'    if value1 <= target <= value2
'      result = - value1 + index + target
'      branch to address
'    else index += delta + 1
'
'  if value1 > value2
'    delta = value1 - value2
'    if value2 <= target <= value1
'      result = value1 + index - target
'      branch to address
'    else index += delta + 1
'
' entry:
'
'  x		value2		x
'  ptra[-1]	value1		d
'  ptra[-2]	index		c
'  ptra[-3]	target		b
'  ptra[-4]	address		a
'
'
' c: CASE value1..value2
'
' entry:
'
'   x		value2		x
'   ptra[-1]	value1		d
'   ptra[-2]	target		b
'   ptra[-3]	address		(ignored)
'
' exit:
'
'   x		target
'   ptra[-1]	address
'
'
range		setq	#4-1		'a b c		look: pop address/target/index/value1 into a/b/c/d
		rdlong	a,--ptra	'a b c		case: pop ?/address/target/value1 into a/b/c/d

		add	ptra,#2*4	'| | c		unpop ?/address
		rfvar	a		'| | c		read address into a
		mov	b,c		'| | c		get target into b

		mov	w,x		'| b c		copy value2 into w

		subs	x,d	wc	'a b c		c = (value1 > value2)
		negc	x		'a b |		x = delta
		add	x,c		'a b |		x = index + delta

		modz	_c	wz	'a b c		z = (value1 > value2)

		cmp	b,c	wc	'a | |		nc = (target >= index)
  if_nc		cmp	x,b	wc	'a | |		nc = (index + delta >= target)

  if_nz		cmps	b,d	wc	'| b c		if nz, nc = (value1 <= target <= value2)
  if_nz_and_nc	cmps	w,b	wc	'| b c
  if_z		cmps	b,w	wc	'| b c		if z, nc = (value2 <= target <= value1)
  if_z_and_nc	cmps	d,b	wc	'| b c

  if_nc		jmp	#reljmp		'| | c		if in range, branch to address
  _ret_		mov	x,c		'| | c		else, get target on top of stack

  if_nc		mov	x,d		'a |		if in range, get result in x
  if_nc		sumnz	x,c		'a |

  if_nc		mov	x,c		'| b		if in range, get result in x
  if_nc		sumnz	x,d		'| b

  if_nc		sumz	x,b		'a b
  if_nc		jmp	#absjmp		'a b		if in range, branch to address
	
		add	ptra,#2*4	'a b		else, unpop address/target
  _ret_		add	x,#1		'a b		x = index + delta + 1
'
'
' LOOKUP/LOOKDOWN done (code at lookd)
'
'
'  x		index
'  ptra[-1]	target
'  ptra[-2]	address
'
'
{
lookd		sub	ptra,#2*4	'pop target+address
	_ret_	mov	x,#0		'get zero on stack top
}
'
'
' CASE done (code at cased)
'
' entry:
'
'   x		target
'   ptra[-1]	address
'   ptra[-2]	new_x
'
' exit:
'
'   x		new_x
'   ptra[-1]
'
{
cased		setq	#2-1		'pop new_x/address into x/y
		rdlong	x,--ptra

		add	y,pbase		'branch to address
	_ret_	rdfast	#0,y
}
'
'
' End of cog LUT code
'
lut_end
'
'
'***********************
'*  Interpreter - hub  *
'***********************
'
		orgh
'
'
' RETURN		Z=0	- return results in stack
' RETURN x,y,z		Z=1	- return args on top of stack
'
'  ptra = dbase				(point to current stack)
'  ptra[-7] --> v			(top of caller stack)
'  ptra[-6] --> pbase | flags		(trap_flag in bit 1, push_flag in bit 0)
'  ptra[-5] --> vbase
'  ptra[-4] --> dbase			(lower stack pointer)
'  ptra[-3] --> mrecv
'  ptra[-2] --> msend
'  ptra[-1] --> w			(bytecode return pointer)
'  ptra -= 7				(point to top of caller stack)
'
'  case {trap_flag, push_flag}
'    %00: restore caller stack
'    %01: return (Z ? stack_args : results)
'    %10: restore caller stack
'    %11: return 0
'
returnh	if_z	mov	y,ptra		'if returning arg(s), save ptra (x holds last arg)
	if_nz	mov	y,dbase		'if returning result(s), save dbase

		mov	ptra,dbase	'ptra points to dbase

		setq	#7-1		'pop v/pbase/vbase/dbase/mrecv/msend/w
		rdlong	v,--ptra	'ptra points to caller's stack top after pop

		rczr	pbase	   wcz	'save Z, get trap_flag into C and push_flag into Z
  if_c_and_z	add	ptra,#1*4	'if trap_flag and push_flag, return #0
  if_c_and_z	mov	v,#0
  if_c_or_nz	jmp	#.top		'if !push_flag, restore caller's stack top

		getnib	z,w,#5		'get return-value count and decrement
		djf	z,#.top		'if 0 return values, restore caller's stack top

		add	ptra,#1*4	'1..15 return values, inc past caller's stack top

		testb	pbase,#30  wz	'restore Z
	if_z	tjz	z,#.xok		'if returning 1 arg, ptra and x are already current
	if_z	neg	v,z		'if returning 2..15 args, get offset (-$01..-$0E)
	if_nz	getbyte	v,w,#3		'if returning 1..15 results, get offset ($00..$7F)
		shl	v,#2		'scale offset
		add	y,v		'add offset

		setq	z		'read args/results into buff
		rdlong	buff,y

		setq	z		'write args/results into stack
		wrlong	buff,ptra++

		sub	ptra,#1*4	'set ptra to caller's new stack top

	if_z	skip	#%11		'if returning 2..15 args, x is already current
		alts	z,#buff		'set stack top to last result
.top		mov	x,v		'restore/update caller's stack top

.xok		shl	pbase,#2	'restore pbase, clearing two lsb's

	_ret_	rdfast	#0,w		'start new bytecode read
'
'
' ABORT			Z=0	- returns 0
' ABORT x		Z=1	- returns arg on top of stack
'
'  repeat
'    ptra = dbase			(point to current stack)
'    ptra[-7] --> v			(top of caller stack)
'    ptra[-6] --> pbase | flags		(trap_flag in bit 1, push_flag in bit 0)
'    ptra[-5] --> vbase
'    ptra[-4] --> dbase			(lower stack pointer)
'    ptra[-3] --> mrecv
'    ptra[-2] --> msend
'    ptra[-1] --> w			(bytecode return pointer)
'    ptra -= 7				(point to top of caller stack)
'  while !trap_flag
'
'  case {Z, push_flag}
'    %00: restore caller stack
'    %01: return 0
'    %10: restore caller stack
'    %11: return stack_arg
'
aborth		mov	ptra,dbase	'ptra points to dbase

		setq	#7-1		'pop v/pbase/vbase/dbase/mrecv/msend/w
		rdlong	v,--ptra	'ptra points to stack top after pop

		ror	pbase,#2  wc	'get trap_flag into c
  if_nc		jmp	#aborth		'if !trap_flag, pop again

		shl	pbase,#2  wc	'restore pbase, get push_flag into c
  if_nc		mov	x,v		'if !push_flag, restore top of caller stack into x
  if_c		add	ptra,#1*4	'if push_flag, inc ptr, x may already hold result
  if_c_and_nz	mov	x,#0		'if push_flag and !Z, return 0

	_ret_	rdfast	#0,w		'start new bytecode read
'
'
' Call method / Make method pointer
'
' operation		compile sequence...
' ---------------------------------------------------------------------------------------
' a: call obj.sub			bc_call_obj_sub		rfvar obj	rfvar sub
' b: call obj[].sub	push obji	bc_call_obji_sub	rfvar obj	rfvar sub
' c: call sub				bc_call_sub				rfvar sub
' d: call ptr()		read var	bc_call_ptr
' e: call recv()			bc_call_recv
' f: call send()	compile_exp	bc_call_send
' g: call sendb				bc_call_sendb		rfvar count	bytes...
' h: call init
'
' i: @obj.sub				bc_mptr_obj_sub		rfvar obj	rfvar sub
' j: @obj[].sub		push obji	bc_mptr_obji_sub	rfvar obj	rfvar sub
' k: @sub				bc_mptr_sub				rfvar sub
'
'
{
callobj		rfvar	w		'a b         g   i j	get obj into w
callsub		rfvar	v		'a b c       |   i j k	get sub into v
		getptr	pb		'a b c       g   i j k	get updated bytecode ptr
		jmp	#callh		'a b |       |   i j k	continue in hub
		jmp	#callsubh	'    c       |		continue in hub ('call sub' is optimized)
callptr		jmp	#callptrh	'      d     |		continue in hub
callrecv	jmp	#callrecvh	'        e   |		continue in hub
callsend	jmp	#callsendh	'          f |		continue in hub
		jmp	#callsendbh	'            g		continue in hub
}

callsendbh	call	#drophot	'            g		drop anchor
		mov	y,w		'            g		get count
		mov	z,pb		'            g		get data address
		setq	#3-1		'            g		push top of stack, count, data address
		wrlong	x,ptra++	'            g
		add	pb,w		'            g		set return address
		setbyte	pb,#2,#3	'            g		set two parameters
		mov	x,#@pri_sendb	'            g		point to spin method
		jmp	#callhot	'            g		call spin method


callrecvh	cmp	mrecv,#0   wz	'        e		if mrecv <> 0 then valid
	if_nz	or	pbase,#%01	'        e		if valid, drop anchor with push flag set
	if_nz	call	#drophot	'        e
		pusha	x		'        e		push top of stack
		mov	x,mrecv		'        e		set top of stack to mrecv method ptr or 0 if invalid
	if_nz	skip	#%1111111_1	'        e		if valid, skip to method ptr call
resumeh		jmp	#resume		'        e		invalid, resume instead of calling method


callsendh	mov	y,x		'        | f		get parameter into y and pop stack
		popa	x		'        | f
		tjz	msend,#resumeh	'        | f		if msend = 0, resume instead of calling method
		call	#drophot	'        | f		drop anchor
		setq	#2-1		'        | f		push top of stack and parameter
		wrlong	x,ptra++	'        | f
		mov	x,msend		'        | f		set top of stack to msend method pointer


callptrh	mov	vbase,x		'      d e f		set vbase to ptr
		rdlong	pbase,vbase	'      d e f		read pbase from vbase
callinit	mov	v,vbase		'      d e f   h	get sub index from vbase[31:20]
		shr	v,#20		'      d e f   h
		zerox	vbase,#19	'      d e f   h	clear vbase msb's so they don't show up in @var
		jmp	#calloffh	'      d e f   h


callh		nop			'a b             i j k	nop (instruction after branch cannot be skipped)

		add	w,x		'| b             | j |	add obj index

		shl	w,#3		'a b             i j |	get obj offsets from w
		add	w,pbase		'a b             i j |
		setq	#2-1		'a b             i j |
		rdlong	y,w		'a b             i j |	y = pbase offset, z = vbase offset

		jmp	#makeptr	'| |             i j k	if method ptr, continue in hub

		add	pbase,y		'a b  			add obj offsets into pbase/vbase
		add	vbase,z		'a b  

callsubh	pusha	x		'a | c			if no call index, push x to save parameter

calloffh	shl	v,#2		'a b c d e f   h	get sub offset
		add	v,pbase		'a b c d e f   h
		rdlong	v,v		'a b c d e f   h	get bytecode params/results/offset

		mov	x,v		'a b c d e f   h	convert offset to branch address
		add	x,pbase		'a b c d e f   h

		and	v,##$7FF00000	'a b c d e f   h  x2	save params/results above return_address
		or	pb,v		'a b c d e f   h

callhot		mov	dbase,dcall	'a b c d e f g h	set dbase to dcall
		mov	ptra,dbase	'a b c d e f g h	point to stack base
		rdlong	dcall,ptra[-1]	'a b c d e f g h	read prior dcall from stack
		wrlong	pb,ptra[-1]	'a b c d e f g h	write params/results/return_address into stack

		getbyte	w,pb,#3		'a b c d e f g h	point past parameters
		shl	w,#2		'a b c d e f g h
		add	ptra,w		'a b c d e f g h

		getnib	w,pb,#5		'a b c d e f g h	clear results
		sub	w,#1	wc	'a b c d e f g h
	if_nc	setq	w		'a b c d e f g h
	if_nc	wrlong	#0,ptra++	'a b c d e f g h	points past results

		jmp	#callgo		'a b c d e f g h	continue in cog

{
callgo		rdfast	#0,x		'a b c d e f g h	return from hub, start new bytecode read
		rfvar	x		'a b c d e f g h	get number of local longs
	_ret_	djnf	x,#.clear	'a b c d e f g h	if zero, continue
.clear		setq	x		'a b c d e f g h	else, clear locals and point stack past them
	_ret_	wrlong	#0,ptra++	'a b c d e f g h
}

makeptr		shl	v,#20		'                i j k	shift up method index (instruction after branch cannot be skipped)
		
		pusha	x		'                i | k	if no index, push x

		mov	y,#0		'                | | k	get pbase/vbase for method
		mov	z,#0		'                | | k

		add	y,pbase		'                i j k	add pbase/vbase for obj
		add	z,vbase		'                i j k

		wrlong	y,z		'                i j k	write pbase to vbase (first vbase long is reserved for pbase ptr)

		zerox	z,#19		'                i j k	insert method index above vbase to make method pointer
		or	z,v		'                i j k

		mov	x,z		'                i j k	set top of stack to method pointer

	_ret_	rdfast	#0,pb		'                i j k	restart bytecode stream
'
'
' a: CASE_FAST init
'
' entry:
'
'   x		index
'   ptra[-1]	address
'
' exit:
'
'   x		address
'
'
' b: CASE_FAST done
'
' entry:
'
'   x		address
'
{
casefi		rflong	v		'a	get index base
		rfword	w		'a	get index limiter
		jmp	#casefih	'a	continue in hub

casefd		jmp	#casefdh	'  b	continue in hub
}

casefih		sub	x,v		'a	zero index
		fle	x,w		'a	limit index
		shl	x,#1		'a	make into word index
		add	pb,#4+2		'a	get rdfast pointer
		add	x,pb		'a	add rdfast pointer into word index
		rdword	a,x		'a	read offset word
		add	a,pb		'a	add rdfast pointer into offset word
casefdh		mov	a,x		'| b	get 'done' address
		popa	x		'a b	pop stack
		add	a,pbase		'| b	add pbase
	_ret_	rdfast	#0,a		'a b	branch to case code
'
'
' Make field
'
'    ^@reg                         -->   00_11111_00000_00000000000rrrrrrrrr
'    ^@reg.[bbbbb addbits sssss]   -->   00_sssss_bbbbb_00000000000rrrrrrrrr
'   ^@byte                         -->   01_00111_00000_aaaaaaaaaaaaaaaaaaaa
'   ^@byte.[bbbbb addbits sssss]   -->   01_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa
'   ^@word                         -->   10_01111_00000_aaaaaaaaaaaaaaaaaaaa
'   ^@word.[bbbbb addbits sssss]   -->   10_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa
'   ^@long                         -->   11_11111_00000_aaaaaaaaaaaaaaaaaaaa
'   ^@long.[bbbbb addbits sssss]   -->   11_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa
'
mfieldh		cmp	rd,rd_field	wz	'bitfield?
	if_z	mov	rd,rdf			'if bitfield, retrieve rd
	if_nz	mov	fb,#0			'if not bitfield, clear fb

		mov	x,sz			'get sz into x

		cmp	rd,rd_word	wcz	'get type into x
		bitnc	x,#6			'rd_byte --> 01
		bitnz	x,#5			'rd_word --> 10
		cmp	rd,rd_byte	wc	'rd_long --> 11  (rd_reg < rd_byte)
	if_c	zerox	x,#4			'rd_reg  --> 00

		shl	x,#5			'get fb into x
		zerox	fb,#4
		or	x,fb

		shl	x,#20			'get reg or ad into x
	if_c	sets	x,rd
	if_nc	zerox	ad,#19
	if_nc	or	x,ad

	_ret_	rdfast	#0,pb			'restart bytecode stream
'
'
' Setup field with index
'
'   I = i * (sssss + 1)
'
'
'   [00_sssss_bbbbb_00000000000rrrrrrrrr][i]   -->   [00_sssss_BBBBB_00000000000RRRRRRRRR]
'
'		rrrrrrrrr00000
'	+		 bbbbb
'	+	IIIIIIIIIIIIII
'	=	RRRRRRRRRBBBBB
'
'
'   [01_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa][i]   -->   [01_sssss_00BBB_AAAAAAAAAAAAAAAAAAAA]
'   [10_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa][i]   -->   [10_sssss_00BBB_AAAAAAAAAAAAAAAAAAAA]
'   [11_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa][i]   -->   [11_sssss_00BBB_AAAAAAAAAAAAAAAAAAAA]
'
'		aaaaaaaaaaaaaaaaaaaa000
'	+			  bbbbb
'	+	IIIIIIIIIIIIIIIIIIIIIII
'	=	AAAAAAAAAAAAAAAAAAAABBB
'
fieldih		mov	y,x			'get index
		popa	x			'pop field, tt_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa

		rol	x,#2+5			'bbbbb_aaaaaaaaaaaaaaaaaaaa_tt_sssss
		test	x,#%11_00000	wz	'z=1 if reg, else byte/word/long

		mov	z,x			'scale index by sssss+1
		and	z,#%11111
		add	z,#1
		getword	w,y,#1
		mul	w,z
		shl	w,#16
		mul	y,z
		add	y,w

		mov	z,x			'get address
		shr	z,#2+5
	if_z	shl	z,#5			'------------------rrrrrrrrr00000 for reg
	if_nz	shl	z,#3			'---------aaaaaaaaaaaaaaaaaaaa000 for byte/word/long

		mov	w,x			'add bbbbb
		shr	w,#32-5
		add	z,w

		add	z,y			'add scaled index

		shl	x,#32-2-5		'tt_sssss_00000_00000000000000000000

		mov	w,z			'install updated bbbbb
	if_z	and	w,#%11111		'keep 5 lsb's for reg
	if_nz	and	w,#%00111		'keep 3 lsb's for byte/word/long
		shl	w,#20
		or	x,w

	if_z	shr	z,#5			'install updated address
	if_z	zerox	z,#8
	if_nz	shr	z,#3
	if_nz	zerox	z,#19
		or	x,z			'(followed by fieldh)
'
'
' Setup field
'
'   [00_sssss_bbbbb_-----------rrrrrrrrr]   -->    reg[-----------rrrrrrrrr].[bbbbb addbits sssss]
'   [01_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa]   -->   byte[aaaaaaaaaaaaaaaaaaaa].[bbbbb addbits sssss]
'   [10_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa]   -->   word[aaaaaaaaaaaaaaaaaaaa].[bbbbb addbits sssss]
'   [11_sssss_bbbbb_aaaaaaaaaaaaaaaaaaaa]   -->   long[aaaaaaaaaaaaaaaaaaaa].[bbbbb addbits sssss]
'
fieldh		testb	x,#31		wc	'get field type
		testb	x,#30		wz

	if_00	mov	rd,rd_reg		'reg?
	if_00	mov	wr,wr_reg
	if_00	sets	rd,x
	if_00	setd	wr,x

	if_01	mov	rd,rd_byte		'byte?
	if_01	mov	wr,wr_byte

	if_10	mov	rd,rd_word		'word?
	if_10	mov	wr,wr_word

	if_11	mov	rd,rd_long		'long?
	if_11	mov	wr,wr_long

		mov	ad,x			'set address in case byte/word/long

		shr	x,#20			'position fs and fb in x

		push	##bit_pop		'ready to setup bitfield
	_ret_	rdfast	#0,pb			'restart bytecode stream and setup bitfield
'
'
' Push structure
' x = structure pointer, y = $80 | byte count
'
structpush	sub	y,#$80		wcz	'get setq value, C=0, Z=0

		rczr	y		wcz	'get long count, trailing byte count into C/Z

    if_00	sub	y,#1			'get setq value to cover structure

		setq	y			'read structure longs into buff
		rdlong	buff,x

    if_same	bmask	z,#31			'clear any undefined bytes in the last long
    if_diff	bmask	z,#15			'00 = $FFFFFFFF, 0 undefined bytes
    if_x1	shr	z,#8			'01 = $000000FF, 3 undefined bytes
		altd	y,#buff			'10 = $0000FFFF, 2 undefined bytes
		and	0-0,z			'11 = $00FFFFFF, 1 undefined byte

		setq	y			'push buff longs onto stack
		wrlong	buff,ptra++

		popa	x			'get top of stack

	_ret_	rdfast	#0,pb			'restart bytecode stream
'
'
' Pop structure
' x = structure pointer, y = byte count, C=0, Z=0
'
structpop	rczr	y		wcz	'get long count, trailing byte count into C/Z

    if_00	sub	y,#1			'get setq value to cover structure

		setq	y			'pop structure longs into buff
		rdlong	buff,--ptra

    if_not_00	alts	y,#buff			'get any trailing bytes from last buff long
    if_not_00	mov	z,0-0

		mov	ptrb,x			'point to structure

    if_not_00	djf	y,#.nolongs		'any longs to write?

		setq	y			'write any longs to structure
		wrlong	buff,ptrb++
.nolongs
    if_1x	wrword	z,ptrb++		'write any trailing bytes to structure
    if_1x	shr	z,#16
    if_x1	wrbyte	z,ptrb

		popa	x			'get top of stack

	_ret_	rdfast	#0,pb			'restart bytecode stream
'
'
'***********************************************
'*  Interpreter - miscellaneous hub bytecodes  *
'***********************************************
'
'
' HUBSET(val)
'
hubset_		hubset	x			'do hubset
	_ret_	popa	x			'get top of stack
'
'
' CLKSET(clkmode,clkfreq)
'
clkset_		mov	z,x			'get clkfreq into z

		setq	#2-1			'get clkmode into y
		rdlong	x,--ptra		'get stack top into x

clkset_init	rep	#99,#1			'use REP to stall interrupts until _ret_

		rdlong	w,#@clkmode_hub		'get current clkmode to avoid (PPPP = %1111) clock glitch
		andn	w,#%11			'switch to 20MHz while maintaining old pll/xtal settings
		hubset	w

		test	y,#%10		wz	'if new pll/xtal settings then switch to 20MHz for 10ms
	if_nz	mov	w,y			'..while new pll/xtal settings take effect
	if_nz	andn	w,#%11
	if_nz	hubset	w
	if_nz	wrlong	##20_000_000,#@clkfreq_hub
	if_nz	waitx	##20_000_000/100

		hubset	y			'now switch to new settings

_debugnop1_	dirh	#63-63			'write clkfreq to rx pin long repository
_debugnop2_	wxpin	z,#63-63
_debugnop3_	dirl	#63-63			'(these 3 are NOP'd by compiler if not DEBUG, else fixed with debug_pin_rx)

		setq	#2-1			'update clkmode and clkfreq
	_ret_	wrlong	y,#@clkmode_hub
'
'
' Read CLKFREQ
'
read_clkfreq	pusha	x

	_ret_	rdlong	x,#@clkfreq_hub
'
'
' COGSPIN(cog,method(parameters),stackadr)
'
' compile sequence:
'
'	cog					(COGSPIN)
'	0..127 parameters
'	method pointer
'	stackadr
'	bc_hub
'	bc_cogspin
'	byte: parameter count
'
'	bc_coginit/bc_coginit_push		(COGINIT)
'
' on entry:
'
'	x	 = stackadr
'	ptra[-1] = method pointer
'	ptra[-2] = last parameter
'	ptra[-?] = first parameter
'	ptra[--] = cog
'	ptra[--] = prior top of stack
'
' on exit:
'
'	x	 = stackadr			ready for COGINIT(cog,pgm,ptr)
'	ptra[-1] = @launch_spin
'	ptra[-2] = cog | %10_0000
'	ptra[-3] = prior top of stack
'
cogspin_	mov	v,x			'save stackadr

		popa	y			'pop method pointer (vbase | method<<20) into y
		rdlong	x,y			'get pbase into x
		setq	#2-1			'write pbase and vbase at stackadr
		wrlong	x,v

		rdbyte	x,pb			'read parameter count
		add	pb,#1		wz	'advance pointer, Z=0 for move_fwd_loop

		mov	y,x			'ptrb points to first parameter
		shl	y,#2
		subr	y,ptra			'(move_fwd_loop sets ptra to y and pops x)
		mov	ptrb,y

		mov	ptra,v			'ptra points to parameter destination
		add	ptra,#6*4

		call	#move_fwd_loop		'copy any parameters, x=cog and ptra=@cog after

		or	x,#%10_0000		'set cog to hub-exec
		mov	y,##launch_spin		'set pgm to @launch_spin
		setq	#2-1			'push cog/pgm
		wrlong	x,ptra++
	_ret_	mov	x,v			'get stackadr on top of stack, ready for COGINIT(cog,pgm,ptr)
'
'
' Launch Spin - invoked by COGINIT
'
' on entry:
'
'	ptra[0]  = pbase
'	ptra[1]  = vbase | method<<20
'	ptra[6+] = any parameters
'
' on exit:
'
'	ptra[-6] = pbase | trap flag
'	ptra[-5] = vbase
'	ptra[-4] = dbase	@params...
'	ptra[-3] = mrecv
'	ptra[-2] = msend
'	ptra[-1] = return (w)	@COGSTOP(COGID)
'	ptra[ 0] = params...
'
launch_spin	loc	ptrb,#\$80000		'point to zeroes in empty hub space

		setq	#ptra-1			'clear reg 0..ptra-1 (cancels mrecv/msend)
		rdlong	0,ptrb

		setq	#reg_end-reg_code-1	'load cog_code
		rdlong	reg_code,#@reg_code

		setq2	#(lut_code-1) & $1FF	'clear lut 0..lut_code-1
		rdlong	0,ptrb

		setq2	#lut_end-lut_code-1	'load lut_code
		rdlong	lut_code & $1FF,rdf

		setq	#2-1			'get pbase/vbase
		rdlong	pbase,ptra

		or	pbase,#%10		'set pbase 'trap' flag

		mov	dbase,ptra		'set dbase to @params
		add	dbase,#6*4

		mov	w,dbase			'set dcall value to be loaded

		setq	#6-1			'write pbase/vbase/dbase/mrecv/msend/w into stack
		wrlong	pbase,ptra

		andn	pbase,#%11		'restore pbase address

		mov	dcall,dbase		'set dcall

		mov	pb,#@stopcog		'set return to COGSTOP(COGID) bytecodes

		push	#wrf_rd			'return to wrf_rd to start xbyte after callinit

		jmp	#callinit		'begin bytecode execution of method in vbase[31:20]
'
'
' COGCHK(cog)
'
cogchk_		cogid	x		wc
	_ret_	muxc	x,_FFFFFFFF

'
'
' a: In-line PASM
' b: REGEXEC(hubadr)
' c: REGLOAD(hubadr)
' d: CALL(anyadr)
'
inline		setq	#16-1			'a		load local variables from hub into buff
		rdlong	buff,dbase		'a
		bith	pb,#31			'a		set flag to restore local variable to hub

		mov	ptrb,pb			'a		get bytecode ptr into ptrb
		skip	##%11100100000111	'a	x2	begin inline_pasm skip pattern

regexec_	skip	##%1111000000		'| b	x2	begin REGEXEC skip pattern
regload_	mov	ptrb,x			'| b c		get hubadr into ptrb

		rdword	w,ptrb++		'a b c		read start register
		rdword	y,ptrb++		'a b c		read length of pasm code, minus 1

		setq	y			'a b c		read in code
		altd	w			'a b c
		rdlong	0-0,ptrb++		'a b c		altd causes ptrb++ to inc by 4, not by (y+1)*4

	_ret_	popa	x			'| | c		REGLOAD done, pop stack

		shl	y,#2			'a |		update bytecode ptr for inline_pasm
		add	y,ptrb			'a |

call_		mov	w,x			'| |   d	get CALL address
		popa	x			'| b   d	pop stack

		mov	y,pb			'| b   d	save bytecode ptr
		mov	z,ptra			'a b   d	save ptra

		call	w			'a b   d	call pasm code (can use pa/pb/ptra/ptrb/stack, C/Z=0)

		mov	pb,y		wc	'a b   d	restore bytecode ptr

	if_c	setq	#16-1			'a b   d	if inline_pasm, restore local variables to hub
	if_c	wrlong	buff,dbase		'a b   d

	_ret_	mov	ptra,z			'a b   d	restore ptra
'
'
' GETREGS(hubadr,cogadr,longs)
' SETREGS(hubadr,cogadr,longs)
'
getregs_	setq	#3-1			'x = longs
		rdlong	a,--ptra		'a = stack top, b = hubadr, c = cogadr

		sub	x,#1		wc	'if longs = 0, nothing to do

  if_nc		cmp	pa,#bc_getregs	wz	'GETREGS or SETREGS?

  if_nc_and_z	setq	x			'GETREGS
  if_nc_and_z	altd	c
  if_nc_and_z	wrlong	0-0,b

  if_nc_and_nz	setq	x			'SETREGS
  if_nc_and_nz	altd	c
  if_nc_and_nz	rdlong	0-0,b

  _ret_		mov	x,a			'set stack top
'
'
' BYTEFILL(dst,val,cnt)		$6A	%010	C=1, Z=0	after test pa,#%110 wcz
' BYTEMOVE(dst,src,cnt)		$6C	%100	C=1, Z=0
' BYTESWAP(adra,adrb,cnt)	$6E	%110	C=0, Z=0
' BYTECOMP(adra,adrb,cnt)	$70	%000	C=0, Z=1
' WORDFILL(dst,val,cnt)		$72	%010	C=1, Z=0
' WORDMOVE(dst,src,cnt)		$74	%100	C=1, Z=0
' WORDSWAP(adra,adrb,cnt)	$76	%110	C=0, Z=0
' WORDCOMP(adra,adrb,cnt)	$78	%000	C=0, Z=1
' LONGFILL(dst,val,cnt)		$7A	%010	C=1, Z=0
' LONGMOVE(dst,src,cnt)		$7C	%100	C=1, Z=0
' LONGSWAP(adra,adrb,cnt)	$7E	%110	C=0, Z=0
' LONGCOMP(adra,adrb,cnt)	$80	%000	C=0, Z=1
'
'
longfill_	shl	x,#1			'cnt<<2 for long
wordfill_	shl	x,#1			'cnt<<1 for word
bytefill_
		setq	#2-1			'pop dst/adra into buff+14
		rdlong	buff+14,--ptra		'pop src/adrb/val into buff+15

		mov	ptrb,buff+15		'set ptrb to src/adrb/val

		test	pa,#%110	wcz	'FILL/MOVE/SWAP/COMP?

  if_c_or_nz	mov	y,ptra			'if FILL/MOVE/SWAP, save ptra and set to dst/adra
  if_c_or_nz	mov	ptra,buff+14

  if_nc_and_nz	loc	pa,#swap_buff		'if SWAP/COMP, load buff and run
  if_nc_and_z	loc	pa,#comp_buff
  if_nc		jmp	#load_buff

		testb	pa,#1		wz	'move (Z=0) or fill (Z=1)?

  if_nz		cmp	ptrb,ptra	wc	'forward or reverse move?
  if_nz_and_nc	jmp	#move_fwd
  if_nz_and_c	jmp	#move_rev


		cmp	pa,#bc_longfill	wc	'word fill?
  if_c		movbyts	buff+15,#%%1010
		cmp	pa,#bc_wordfill	wc	'byte fill?
  if_c		movbyts	buff+15,#%%0000

		loc	pa,#fill_buff		'write fill pattern to stack
		call	#load_buff
		setq	#16-1			'read fill pattern from stack into buff
		rdlong	buff,y


move_fwd	shr	x,#1		wc	'forward move/fill
  if_c_and_nz	rdbyte	buff,ptrb++
  if_c		wrbyte	buff,ptra++

		shr	x,#1		wc
  if_c_and_nz	rdword	buff,ptrb++
  if_c		wrword	buff,ptra++

move_fwd_loop	mov	w,#16
		fle	w,x
		sub	x,w
		djf	w,#move_done
  if_nz		setq	w
  if_nz		rdlong	buff,ptrb++
		setq	w
		wrlong	buff,ptra++
		jmp	#move_fwd_loop


move_rev	add	ptrb,x			'reverse move
		add	ptra,x

		shr	x,#1		wc
  if_c		rdbyte	buff,--ptrb
  if_c		wrbyte	buff,--ptra

		shr	x,#1		wc
  if_c		rdword	buff,--ptrb
  if_c		wrword	buff,--ptra

move_rev_loop	mov	w,#16
		fle	w,x
		sub	x,w
		djf	w,#move_done
		setq	w
		rdlong	buff,--ptrb
		setq	w
		wrlong	buff,--ptra
		jmp	#move_rev_loop


move_done	mov	ptra,y			'restore ptra
	_ret_	popa	x			'get top of stack


fill_buff	not	buff+5,buff+15		'write fill pattern to stack
		shr	buff+5,#9
		not	buff+5
		setd	buff+6,buff+15
		setq	#16-1
		augd	#0			'buff+5
	_ret_	wrlong	#0,y			'buff+6

swap_buff	rdlong	w,ptra			'swap longs first for speed
		rdlong	z,ptrb
		sub	x,#4		wc
	if_nc	wrlong	w,ptrb++
	if_nc	wrlong	z,ptra++
	if_nc	jmp	#swap_buff
		add	x,#4		wz	'swap any trailing bytes
.bytes	if_nz	wrbyte	w,ptrb++
	if_nz	wrbyte	z,ptra++
	if_nz	shr	w,#8
	if_nz	shr	z,#8
	if_nz	djnz	x,#.bytes
		jmp	#\move_done

comp_buff _ret_	tjnz	x,#.go			'compare hub memory, if cnt=0 then return 0
.go		rdfast	#0,buff+14
.loop		rflong	y			'compare longs for speed
		rdlong	w,ptrb++
		xor	y,w		wz	'xor longs, match?
		sub	x,#4		wc	'decrement cnt by 4 bytes, underflow?
  if_z_and_nc	tjnz	x,#.loop		'if match and cnt > 0, loop
	if_c	neg	x			'if cnt underflow, negate -3/-2/-1 to get 1/2/3
	if_c	shl	x,#3			'shift 1/2/3 left by 3 to get 8/16/24
	if_c	shl	y,x		wz	'shift xor left to get rid of unwanted bytes, match?
	_ret_	muxz	x,_FFFFFFFF
'
'
' STRSIZE(adr) : size
' STRCOMP(adra,adrb) : match
' STRCOPY(dst,src,max)
'
strsize_	loc	pa,#strsize_buff
		skip	#%1
strcomp_	loc	pa,#strcomp_buff
		skip	#%1
strcopy_	loc	pa,#strcopy_buff

load_buff	setq	#14-1			'buff program is max 14 longs
		rdlong	buff,pa
		jmp	#buff


strsize_buff	rdfast	#0,x			'measure string
		mov	x,#0
.loop		rfbyte	y		wz
	if_nz	ijnz	x,#.loop
		ret

strcomp_buff	popa	ptrb			'compare strings
		rdfast	#0,x
.loop		rdbyte	x,ptrb++
		rfbyte	y
		cmp	x,y		wz
	if_z	tjnz	x,#.loop
	_ret_	muxz	x,_FFFFFFFF

strcopy_buff	mov	w,x			'copy string, get max into w
		setq	#3-1			'pop top of stack into x, dst into y, src into z
		rdlong	x,--ptra
		mov	ptrb,y
		rdfast	#0,z
.loop		rfbyte	y		wz
		wrbyte	y,ptrb++
	if_nz	djnf	w,#.loop
	_ret_	wrbyte	#0,--ptrb
'
'
' GETCRC(ptr,poly,cnt) : crc
'
getcrc_		setq	#2-1			'pop ptr into buff+14
		rdlong	buff+14,--ptra		'pop poly into buff+15

		mov	y,x			'get cnt into y

		encod	x,buff+15		'get starting value into x
		bmask	x

		loc	pa,#getcrc_buff		'if cnt <> 0 then run crc, else x=result
	_ret_	tjnz	y,#load_buff


getcrc_buff	rdfast	#0,buff+14		'compute crc of bytes
.loop		rfbyte	w
		shl	w,#24
		setq	w
		crcnib	x,buff+15
		crcnib	x,buff+15
	_ret_	djnz	y,#.loop
'
'
' WAITUS(us)
' WAITMS(ms)
'
waitus_		getct	w			'get ct now to minimize error

		rdlong	y,#@clkfreq_hub		'get clock frequency

		rep	@.stall,#1		'use REP to stall interrupts to protect cordic operation
		qmul	y,x			'multiply clock frequency by us/ms
		getqx	x
		getqy	y
.stall
		cmp	pa,#bc_waitus	wz	'us or ms time unit?
		mov	z,##1000
	if_z	mul	z,z

		rep	@.stall2,#1		'use REP to stall interrupts to protect cordic operation
		setq	y			'divide by time unit
		qdiv	x,z
		getqx	x
.stall2
		add	x,w			'add ct

		jmp	#pwct			'do WAITCT
'
'
' GETMS() : millseconds
' GETSEC() : seconds
' MULDIV64(m1,m2,d) : quotient
'
muldiv64_	setq	#2-1			'pop m1 and m2, open top of stack
		rdlong	y,--ptra		'x=d, y=m1, z=m2

		rep	@.stall,#1		'use REP to stall interrupts to protect cordic operation
		qmul	y,z			'multiply m1 * m2
		getqx	y			'product in {z,y}
		getqy	z
.stall
		skip	#%11_11_1		'skip to rep


getms_		pusha	x			'push stack to open top of stack

		rdlong	w,#@clkfreq_hub		'get clkfreq into w and x
		mov	x,w

		getct	z		wc	'get 64-bit clock count into {z,y}
		getct	y

		rep	@.stall,#1		'use REP to stall interrupts to protect cordic operation
		setq	z			'divide {z,y} by x
		qdiv	y,x
		getqy	y			'remainder in y (fractional seconds)
		getqx	x			'quotient in x (seconds)
.stall
		cmp	pa,#bc_getms	wz	'if not GETMS then done
	if_nz	ret

		rep	@.stall2,#1		'use REP to stall interrupts to protect cordic operation
		qmul	x,##1000		'multiply seconds by 1000 to get whole-second milliseconds
		getqx	x
.stall2
		nop				'accommodate any pending interrupt

		rep	@.stall3,#1		'use REP stall interrupts to protect cordic operation
		qfrac	y,w			'compute (fractional seconds << 32 / clkfreq) to get scale
		getqx	y			'get scale ($FFFF_FFFF = ~1.0)
.stall3
		nop				'accommodate any pending interrupt

		rep	@.stall4,#1		'use REP to stall interrupts to protect cordic operation
		qmul	y,##1000		'multiply scale by 1000 to get fractional-second milliseconds
		getqy	y			'get fractional-second milliseconds (0..999)
.stall4
	_ret_	add	x,y			'add fractional-second milliseconds into whole-second milliseconds
'
'
' QSIN(rho,theta,twopi) : y
' QCOS(rho,theta,twopi) : x
'
qsin_		setq	#2-1			'pop rho and theta, open top of stack
		rdlong	y,--ptra		'x=twopi, y=rho, z=theta

		tjz	x,#.fullscale

		rep	@.stall,#1		'use REP to stall interrupts to protect cordic operation
		qfrac	#1,x			'divide $1_0000_0000 by twopi
		getqx	x			'get angle unit
.stall
		nop				'accommodate any pending interrupt

		rep	@.stall2,#1		'use REP to stall interrupts to protect cordic operation
		qmul	z,x			'multiply theta by angle unit to get 32-bit angle
		getqx	z
.stall2
.fullscale	cmp	pa,#bc_qsin	wz	'return sine or cosine?

		rep	@.stall3,#1		'use REP to stall interrupts to protect cordic operation
		qrotate	y,z			'rotate (rho,0) by theta
	if_z	getqy	x
	if_nz	getqx	x
.stall3
		ret
'
'
' ROTXY(x,y,t) : rotx, roty
' POLXY(r,t) : x, y
' XYPOL(x,y) : r, t
'
rotxy_		setq	#2-1			'pop x and y for ROTXY
polxy_		rdlong	y,--ptra		'pop r/x for POLXY/XYPOL
		cmp	pa,#bc_polxy	wcz	'flags differentiate ROTXY/POLXY/XYPOL
		rep	#99,#1			'use REP to stall interrupts to protect cordic operation until _ret_
	if_b	setq	z			'if ROTXY, do SETQ
	if_be	qrotate	y,x			'if ROTXY/POLXY, do QROTATE
	if_a	qvector	y,x			'if XYPOL, do QVECTOR
		getqx	x			'get results
		pusha	x
	_ret_	getqy	x
'
'
' PINREAD(pins) : in
'
pinread_	testb	x,#5	wc		'read ina or inb
	if_nc	mov	a,ina
	if_c	mov	a,inb
		ror	a,x			'lsb-justify
		shr	x,#6			'trim
		zerox	a,x
	_ret_	mov	x,a
'
'
' PINWRITE(pins,val)
'
pinwrite_	mov	w,x			'w=val

		setq	#2-1			'pop pins and new top of stack
		rdlong	x,--ptra		'y=pins

		ror	y,#6	wc		'get outa/outb flag into c

		bmask	v,y			'make mask
		rol	y,#6

		rol	v,y			'justify mask
		rol	w,y			'justify val

	if_nc	setq	v			'mux val into outa using mask
	if_nc	muxq	outa,w

	if_c	setq	v			'mux val into outb using mask
	if_c	muxq	outb,w

	_ret_	dirh	y			'enable outputs
'
'
' PINSTART(pins,mode,xval,yval)
'
pinstart_	setq	#4-1			'pop parameters, including new top of stack
		rdlong	a,--ptra		'a=top of stack, b=pins, c=mode, d=xval, x=yval
		fltl	b			'reset smart pin(s)
		wrpin	c,b			'set smart pin(s) mode
		wxpin	d,b			'set smart pin(s) x
		wypin	x,b			'set smart pin(s) y
		drvl	b			'enable smart pin(s)
	_ret_	mov	x,a			'set top of stack
'
'
' PINCLEAR(pins)
'
pinclear_	fltl	x			'float pin to put smart pin in reset state
		wrpin	#0,x			'clear smart pin mode
	_ret_	popa	x			'get top of stack
'
'
'************************************************
'*  Interpreter - floating-point hub bytecodes  *
'************************************************
'
'
' NAN(float)		float ma --> boolean x
'
nan_		call	#unpackf		'unpack float

	_ret_	neg	x,na			'return NaN status
'
'
' -.float		float ma --> float ma
'
fneg_	_ret_	bitnot	ma,#31			'negate float
'
'
' FABS(float)		float ma --> float ma
'
fabs_	_ret_	bitl	ma,#31			'absolutize float
'
'
' FSQRT(float)		float ma --> float ma
'
fsqrt_		call	#unpackf		'unpack float

		tjz	ma,#fabs_		'if mantissa zero, got result, use _ret_ in FABS

		or	na,sa			'if negative, result = NaN

		sar	xa,#1		wc	'halve root exponent
	if_nc	shr	ma,#1			'if exponent was even, shift mantissa down
		sub	xa,#1			'decrement to account for bit29 justification

		rep	@.stall,#1		'use REP to stall interrupts to protect cordic operation
		qsqrt	#0,ma			'compute square root of mantissa
		getqx	ma
.stall
		jmp	#packf			'pack result
'
'
' float -. float
' float +. float
'
fsub_		bitnot	ma,#31			'negate right-hand float

fadd_		call	#unpackf2		'unpack two floats

		or	na,nb			'if either NaN, result NaN

		test	sa		wz	'negate ma?
		negnz	ma

		test	sb		wz	'negate mb?
		negnz	mb

		mov	y,xa			'determine greater exponent
		subs	y,xb		wcz	'xa > xb ?

		abs	y			'absolutize and clamp exponent difference
		fle	y,#31

	if_a	sar	mb,y			'shift lower-exponent mantissa down
	if_be	sar	ma,y
	if_be	mov	xa,xb

		add	ma,mb			'add mantissas
		abs	ma		wc	'absolutize result
		wrc	sa			'set sign

		jmp	#packf			'pack result
'
'
' float *. float
'
fmul_		call	#unpackf2		'unpack two floats

		or	na,nb			'if either NaN, result NaN

		xor	sa,sb			'xor signs
		add	xa,xb			'add exponents

		rep	@.stall,#1		'use REP to stall interrupts to protect cordic operation
		qmul	ma,mb			'compute upper product of ma * mb
		getqy	ma
.stall
		shl	ma,#3			'justify product

		jmp	#packf			'pack result
'
'
' float /. float
'
fdiv_		call	#unpackf2		'unpack two floats

		or	na,nb			'if either Nan, result NaN

		test	mb		wz	'if denominator zero, result NaN
	if_z	mov	na,#1

		xor	sa,sb			'xor signs
		sub	xa,xb			'subtract exponents

		shr	ma,#1			'make ma < mb

		rep	@.stall,#1		'use REP to stall interrupts to protect cordic operation
		qfrac	ma,mb			'compute quotient of (ma << 32) / mb
		getqx	ma
.stall
		shr	ma,#2			'justify quotient

		jmp	#packf			'pack result
'
'
' 001: float <.  float		 --> boolean x
' 010: float >.  float		 --> boolean x
' 011: float <>. float		 --> boolean x
' 100: float ==. float		 --> boolean x
' 101: float <=. float		 --> boolean x
' 110: float >=. float		 --> boolean x
'
frel_		popa	w			'pop left-side float

		bitl	w,#31		wcz	'make left-side comparable
		cmp	w,##$7F800001	wc	'NaN?
	if_nc	skip	#%1111			'if NaN, return false
	if_z	neg	w			'+/- %0_xxxxxxxx_mmmmmmmmmmmmmmmmmmmmmmm

		bitl	x,#31		wcz	'make right-side comparable
		cmp	x,##$7F800001	wc	'NaN?
	if_nc	skip	#%111111		'if NaN, return false
	if_z	neg	x			'+/- %0_xxxxxxxx_mmmmmmmmmmmmmmmmmmmmmmm

		cmps	w,x		wcz	'do comparison
	if_z	mov	y,#%1000		'equal?
	if_nz	mov	y,#%0100		'above?
	if_c	mov	y,#%0010		'below?
		test	y,pa		wc	'test mask

	_ret_	muxc	x,_FFFFFFFF		'return boolean
'
'
' TRUNC(float)		float ma --> integer ma
' ROUND(float)		float ma --> integer ma
'
round_		call	#unpackf		'unpack float

		add	xa,#1			'if exponent < -1 or exponent > 30 then return zero
		cmp	xa,#32		wc
	if_nc	mov	ma,#0

		shl	ma,#31-29
		subr	xa,#31
		shr	ma,xa
		testb	pa,#1		wc	'TRUNC or ROUND?
	if_c	add	ma,#1
		shr	ma,#1
		testb	sa,#0		wc
	_ret_	negc	ma
'
'
' FLOAT(integer)	integer ma --> float ma
'
float_		mov	na,#0			'clear NaN
		abs	ma		wc	'get sign, make integer absolute
		wrc	sa			'set sign
		encod	xa,ma			'get exponent
		ror	ma,xa			'bit29-justify mantissa
		ror	ma,#1
		shr	ma,#2

		jmp	#packf			'pack result
'
'
' Unpack two floats
'
unpackf2	call	#unpackf		'unpack ma

		mov	nb,na			'copy na/sa/xa/ma to nb/sb/xb/mb
		mov	sb,sa
		mov	xb,xa
		mov	mb,ma

		popa	ma			'pop new ma (followed by fp_unpack)
'
'
' Unpack float		float ma --> na,sa,xa,ma
'
unpackf		bitl	ma,#31		wcz	'read and clear sign
		wrc	sa

		cmpr	ma,##$7F800000	wc	'check for NaN
		wrc	na

		mov	xa,ma			'get exponent
		shr	xa,#32-1-8	wz

		zerox	ma,#22			'get mantissa

	if_nz	bith	ma,#23			'if exponent <> 0 then insert leading one
	if_nz	shl	ma,#29-23		'...bit29-justify mantissa

	if_z	encod	xa,ma			'if exponent = 0 then get magnitude of mantissa
	if_z	ror	ma,xa			'...bit29-justify mantissa
	if_z	ror	ma,#32-29
	if_z	sub	xa,#22			'...adjust exponent to -22..0

	_ret_	sub	xa,#127			'unbias exponent
'
'
' Pack float		na,sa,xa,ma --> float ma
'
packf		testbn	na,#0		wc	'if NaN, result $FFFFFFFF (c=0 if na set)
	if_nc	not	ma,#0

	if_c	encod	y,ma		wc	'determine magnitude of mantissa (c=0 if ma=0)
	if_nc	ret				'if NaN or mantissa=0 (result 0), done

		ror	ma,y			'msb-justify mantissa without leading 1
		bitl	ma,#0			'clear leading 1 now in lsb

		mov	mb,ma			'check if mantissa is even with 0.500 fraction
		zerox	mb,#9		wc	'clear msb's, c=0 for addx in case no rounding
		cmp	mb,#%0100000000	wz	'even with 0.500 fraction?
	if_nz	add	ma,#%0100000000	wc	'if not, round up mantissa by 0.500

		addx	xa,y			'adjust exponent and account for rounding overflow
		add	xa,#127-29		'bias exponent

		fges	xa,##-23		'limit exponent to -23..255
		fles	xa,#255		wc	'if 255 and mantissa not 0, NaN
	if_c	not	ma,#0			'if >255, force Nan by making mantissa not 0

		cmps	xa,#1		wc	'exponent < 1?

	if_c	rcr	ma,#1			'if so, replace leading 1
	if_c	neg	xa			'shift mantissa down by exponent
	if_c	shr	ma,xa			'if exponent is -23, mantissa becomes 0

		shr	ma,#8			'make room for exponent
	if_nc	setbyte	ma,xa,#3		'if exponent < 1 then leave at 0, else install

		testb	sa,#0		wc	'install sign bit
	_ret_	rcr	ma,#1
'
'
'*********
'*  END  *
'*********
'
'
' Test bytecode program 
'
		alignl				'align to long for clean pbase
test_pbase	'file	"untitled.obj"
		alignl				'align to long for clean vbase
test_vbase	'long	0[100]
		alignl				'align to long for clean dbase
test_dbase	'long	0[100]
